<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>嵌入式 on Mountainatic's Blog</title><link>https://mountainatic.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/</link><description>Recent content in 嵌入式 on Mountainatic's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Mountainatic</copyright><lastBuildDate>Sat, 16 Aug 2025 21:00:00 +0800</lastBuildDate><atom:link href="https://mountainatic.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>STM32 HAL 库基础</title><link>https://mountainatic.github.io/posts/stm32-hal-basics/</link><pubDate>Sat, 16 Aug 2025 21:00:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/stm32-hal-basics/</guid><description>&lt;h1 id="点灯之前">点灯之前……
&lt;/h1>&lt;p>STM32 相比与 8051 系列太复杂了，不是我说，在 STC89C52RC 中，你可以清楚地看到每个寄存器是干啥的，直接操控寄存器来完成每个控制动作，同时执行逻辑也很清晰，一条由 RAM 到 ALU 的流水线，但是到了 STM32 来说，两者同样是「改良型哈弗架构」，后者却是 32 位的微控制器，在单寄存器能实现 32 位数据的同时，即使是最低端的 F1 系列仍然具有数以百计的寄存器，高端型号寄存器数目甚至突破千位，寄存器的记忆本身就是一个麻烦的地方，而正是基于寄存器设计的官方库文件，标准库，也在数年前被弃用。在官方指导下，人们正式转向了经过封装抽象过的 HAL 库，HAL 本身即为 &amp;ldquo;Hardware Abstraction Layer（硬件抽象层）&amp;rdquo; 的缩写，通过将对寄存器的操作封装位函数，实现了以调用函数为基础的程序编写，此时，对于寄存器的高阶需求则全面转向与 HAL 相配套的 LL 库。&lt;/p>
&lt;blockquote>
&lt;p>[!Note] 改良哈弗架构是什么？
众所周知，在图灵机理想模型具象化之后，冯依诺曼机作为一种工程架构被提出，即计算机需要由运算器、控制器、存储器、输入设备、输出设备五个部件组成。&lt;/p>
&lt;p>由这种架构思维，发展出了多种实际架构，如程序指令和数据存放在同一个存储空间中，并且共用同一条总线（连接CPU和存储器的通道）的&lt;strong>冯依诺曼架构&lt;/strong>，不难想到其灵活性很好高，程序可以像数据一样被修改，但是缺点也很明显，因为共用一条总线，CPU无法同时读取指令和读写数据，会产生所谓的“冯·诺依曼瓶颈”，限制了性能。&lt;/p>
&lt;p>程序指令和数据分别存放在两个独立的存储空间中，并且各自拥有独立的总线，拥有两类不同的指令，此时CPU可以同时读取指令和读写数据，速度非常快，突破了冯·诺依曼瓶颈。缺点也很明显，结构相对复杂，并且由于指令和数据严格分离，程序在运行时不能轻易地修改自身。&lt;/p>
&lt;p>于是想要兼具两者特点的「改良型哈弗架构」出现了，&lt;strong>在CPU内核层面&lt;/strong>，它是哈佛架构：CPU内核拥有两条独立的总线：一条叫I-Bus (Instruction Bus)，专门用于去获取程序指令；另一条叫D-Bus (Data Bus)，专门用于读写数据。而&lt;strong>在内存管理层面&lt;/strong>，它又是统一的冯·诺依曼架构：虽然有两条总线，但这两条总线最终都连接到了一个统一的、4GB的地址空间上。无论是存放程序的Flash，还是存放数据的SRAM，都被映射到了这个统一的地址空间里。CPU在一个时钟周期内，可以&lt;strong>一边执行上一条指令，一边预取下一条指令&lt;/strong>，极大地提高了流水线效率和执行速度。&lt;/p>
&lt;/blockquote>
&lt;p>HAL 库的设计自有其逻辑，核心主要是「对象」，将外设视为多个独立的对象，通过对象组织寄存器，由于 C 中并没有对象的概念，因此 ST 大量使用了结构体和函数对该外设对象的进行封装，称作&lt;strong>句柄（Handle）&lt;/strong>&lt;/p>
&lt;p>句柄的命名是由固定格式的，即 &lt;code>name_HandleTypeDef&lt;/code>，如 &lt;code>UART_HandleTypeDef&lt;/code> 即是串口的句柄、&lt;code>I2C_HandleTypeDef&lt;/code> 就是 I&lt;sup>2&lt;/sup>C的句柄，其既包含了该外设的所有配置参数、也记录了其实时状态。&lt;/p>
&lt;p>HAL 库的外设初始化总是分为四步：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>使能时钟&lt;/strong>：STM32 在初始情况下总是默认关闭所有外设，为此需要配置其属于开启状态
&lt;ul>
&lt;li>外设本身运作需要时钟：此时即需要调用 &lt;code>__HAL_RCC_name_CLK_ENABLE()&lt;/code>，&lt;code>name&lt;/code> 为外设名称，如 &lt;code>LPUART1&lt;/code>&lt;/li>
&lt;li>外设用到的 GPIO 引脚需要时钟：此时需要调用 &lt;code>__HAL_RCC_GPIOnumber_CLK_ENABLE()&lt;/code>，&lt;code>number&lt;/code> 为 GPIO 引脚编号，如 &lt;code>GPIOA&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>配置 GPIO 输出模式&lt;/strong>：为了配置 GPIO 口，我们需要定义并一张 &lt;code>GPIO_InitTypeDef&lt;/code> 类型的表单，当定义结束后，通过 &lt;code>HAL_GPIO_Init()&lt;/code> 函数来提交申请。 对于该结构体如何定义，在代码里保持按下 &lt;code>Ctrl&lt;/code>并使用鼠标点击即可得到其定义
&lt;ul>
&lt;li>&lt;code>uint32_t Pin&lt;/code>：当前端口内（如前所述 &lt;code>GPIOA&lt;/code>）的&lt;strong>针脚编号&lt;/strong>，可以是 &lt;code>GPIO_PIN_number&lt;/code>，&lt;code>number&lt;/code> 取引脚编号，也可以是 &lt;code>GPIO_PIN_ALL&lt;/code> 来指该端口的所有针脚，也可以使用“按位或 &lt;code>|&lt;/code>”来指定多个引脚&lt;/li>
&lt;li>&lt;code>uint32_t Mode&lt;/code>：&lt;strong>输出/输出模式&lt;/strong>，主要有 &lt;code>GPIO_MODE_INPUT&lt;/code> 输入模式、&lt;code>GPIO_MODE_OUTPUT_PP&lt;/code> 推挽输出模式、&lt;code>GPIO_MODE_OUTPUT_OD&lt;/code> 开漏输出模式、&lt;code>GPIO_MODE_AF_PP&lt;/code> / &lt;code>GPIO_MODE_AF_OD&lt;/code> 复用功能模式、&lt;code>GPIO_MODE_ANALOG&lt;/code> 模拟模式&lt;/li>
&lt;li>&lt;code>uint32_t Pull&lt;/code>：&lt;strong>默认倾向&lt;/strong>，&lt;code>GPIO_NOPULL&lt;/code> 针脚浮空，无上拉或下拉、&lt;code>GPIO_PULLUP&lt;/code> 上拉、&lt;code>GPIO_PULLDOWN&lt;/code> 下拉&lt;/li>
&lt;li>&lt;code>uint32_t Speed&lt;/code>：&lt;strong>反应速度&lt;/strong>，即电平从高到低或从低到高变化的快慢，由“压摆率”实现。参数为 &lt;code>GPIO_SPEED_FREQ_speed&lt;/code> ，其中 &lt;code>speed&lt;/code> 可选 &lt;code>LOW&lt;/code>、&lt;code>MEDIUM&lt;/code>、&lt;code>HIGH&lt;/code>、&lt;code>VERY_HIGH&lt;/code>，速度越高功耗越大，EMI 更强，会产生更尖锐的信号边缘，一般选满足需求的最低速度&lt;/li>
&lt;li>&lt;code>uint32_t Alternate&lt;/code>：&lt;strong>复用指定&lt;/strong>，当 &lt;code>Mode&lt;/code> 为复用模式时，该参数有效，其被用来指定该引脚要被复用为何种功能，功能的 &lt;code>AF&lt;/code> 编号由 Datasheet 给出，也可使用 HAL 库中的别名&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>配置外设本身&lt;/strong>：为了配置外设本身，我们需要进行以下步骤
&lt;ul>
&lt;li>&lt;strong>创建外设句柄&lt;/strong>：使用 &lt;strong>device_HandTypeDef name&lt;/strong> 创建一个命名为 &lt;strong>name&lt;/strong> 关于外设 &lt;strong>device&lt;/strong> 的句柄&lt;/li>
&lt;li>&lt;strong>填写参数&lt;/strong>：根据 HAL 定制的要求，将句柄所需参数填写入结构体表单，即定义结构体中的变量值&lt;/li>
&lt;li>&lt;strong>初始化外设&lt;/strong>：调用 &lt;code>HAL_device_Init&lt;/code> 函数，传入所需变量，如 &lt;code>HAL_GPIO_Init( GPIOA, &amp;amp;name)&lt;/code> 传入 GPIO 端口编号与结构体表单地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>（可选）配置中断&lt;/strong>：若要实现非阻塞式数据处理，则可将外设绑定至中断进行，一般有两步：
&lt;ul>
&lt;li>先&lt;strong>设定中断优先级&lt;/strong>：&lt;code>HAL_NVIC_SetPriority()&lt;/code>，三个参数
&lt;ul>
&lt;li>&lt;code>IRQn&lt;/code>：外设中断编号&lt;/li>
&lt;li>&lt;code>PreemptPriority&lt;/code>：抢占优先级，在 G4 系列中，值为 0-15，数字越小优先级越高，级别高低直接决定了目前执行的中断是否能被突发的另一个中断打断，高能打断低&lt;/li>
&lt;li>&lt;code>SubPriority&lt;/code>：响应优先级 / 亚优先级，当两个中断优先级一致且需要一个打断另一个时候，又或者是两个中断同时发生时候，依靠该值比较谁先发生，值越小优先级越高&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>后&lt;strong>使能中断&lt;/strong>：&lt;code>HAL_NVIC_EnableIRQ()&lt;/code>，参数为 &lt;code>IRQn_Type IRQn&lt;/code> 其中 &lt;code>IQRn&lt;/code> 是枚举类型，是每个外设唯一的中断编号，在头文件中预置，如 &lt;code>USART1_IQRn&lt;/code> 为串口 1 中断、&lt;code>TIM2_IQRn&lt;/code> 为定时器 2 中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用函数操作外设&lt;/strong>：外设操作求公约数的的话……大概就是以下几个
&lt;ul>
&lt;li>启动/发送/接收（&lt;strong>轮询模式&lt;/strong>，会阻塞）：一般以 &lt;code>HAL_device_...()&lt;/code> 命名，如 &lt;code>HAL_UART_Transmit()&lt;/code>&lt;/li>
&lt;li>启动/发送/接收（&lt;strong>中断&lt;/strong>模式，不阻塞）：一般以 &lt;code>HAL_device_..._IT()&lt;/code> 命名，如 &lt;code>HAL_UART_Receive_IT()&lt;/code>&lt;/li>
&lt;li>启动/发送/接收（&lt;strong>DMA&lt;/strong>模式，不阻塞）：一般以 &lt;code>HAL_device_..._DMA()&lt;/code> 命名，&lt;code>HAL_I2C_Master_Transmit_DMA()&lt;/code>&lt;/li>
&lt;li>中断处理函数：&lt;code>device_IRQHandler()&lt;/code> ，例如 &lt;code>LPUART1_IRQHandler()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Note]
到这里这一部分算是结束了 hhh，其实这部分介绍主要是理清思路的，除了操作函数外，所有的代码都不用手写的 hhh，而我们的 STM32CubeMX 就是干这个的，图形化生成出来的就是时钟设定、以及各个外设与端口的设定代码，实际上也就解答了大部分 STM32CubeMX 怎么配置的问题（除了时钟树）&lt;/p>
&lt;/blockquote>
&lt;h1 id="一点灯">一、点灯
&lt;/h1>&lt;blockquote>
&lt;p>[!Note]
前期只使用 PIO 自带配置创建项目&lt;/p>
&lt;/blockquote>
&lt;p>PIO 的项目代码内部不需要 &lt;code>SystemClock_Config()&lt;/code> 函数来初始化时钟，起码自带配置创建时是不需要的，加上能过编译烧录……但是会 HardFault&lt;/p>
&lt;p>点灯代码如下：&lt;/p></description></item><item><title>基于 VSCode + PlatformIO IDE + STM32CubeMX 的现代 STM32 工具</title><link>https://mountainatic.github.io/posts/stm32-modern-tools/</link><pubDate>Sat, 16 Aug 2025 20:30:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/stm32-modern-tools/</guid><description>&lt;h1 id="建议的工具">建议的工具
&lt;/h1>&lt;ul>
&lt;li>VSCode&lt;/li>
&lt;li>VSCode 插件 Platform IDE&lt;/li>
&lt;li>良好的科学上网环境&lt;/li>
&lt;li>STM32CubeMX&lt;/li>
&lt;li>基于 STM32G474RE 的 Nucleo G474RE 开发板&lt;/li>
&lt;li>有 8051 如 STC89C52RC 的一点基础&lt;/li>
&lt;/ul>
&lt;h1 id="安装">安装
&lt;/h1>&lt;p>首先在 VSCode 内装载 Platform IDE 插件，注意科学上网环境，会下载 PlatformIO Core 以及相关组件在 &lt;code>C:\Users\&amp;quot;你的用户名字&amp;quot;&lt;/code>，即个人文件夹下，等待完成后能够显示出如下 PIO Home，若未显示，请点击左侧 &lt;code>Quick Access -&amp;gt; PIO Home -&amp;gt; Open&lt;/code> 以打开，该页面基于本地服务，即 &lt;code>localhost&lt;/code> 下的端口服务，所以请务必检查可能的冲突，如来自 WSL 或 Hyper-V 等服务的自动保留端口与 PIO 的服务端口（好像是 3030）是否有冲突，具体可通过命令查询，不在此赘述，可搜索相关案例以及参考：&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.51cto.com/u_15259603/5552419" target="_blank" rel="noopener"
>【问题解决】我遇到并解决PlatformIO无法使用的各种问题汇总及解决方法，简单粗暴使用的网络问题解决方法&amp;hellip;_51CTO博客_platformio 调试&lt;/a>&lt;/p>
&lt;p>同时官方文档也能提供帮助：&lt;a class="link" href="https://docs.platformio.org/en/latest/" target="_blank" rel="noopener"
>Your Gateway to Embedded Software Development Excellence — PlatformIO latest documentation&lt;/a>&lt;/p>
&lt;p>访问官方指南可得到更为详细的介绍：&lt;a class="link" href="https://docs.platformio.org/en/latest/integration/ide/vscode.html#ide-vscode" target="_blank" rel="noopener"
>PlatformIO IDE for VSCode — PlatformIO 最新文档&lt;/a>&lt;/p>
&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/stm32-modern-tools/Installed.png"
loading="lazy"
alt="安装完成界面"
class="responsive-image"
>
&lt;figcaption>安装完成界面&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h1 id="项目构建">项目构建
&lt;/h1>&lt;p>项目构建有两种方式，其一为直接使用 PIO 自带进行 &lt;code>New Project&lt;/code>，该方式无需设定时钟树和外板载外设，均由官方预置，对相当一部分板子做了适配；其二为 STM32CubeMX 选择 CMake/Makefile 编译来创建通用工程，由命令行导入，也需要对 PIO 方面进行配置。优点是可以自由配置时钟和外设，但是需要对 PIO 进行修改。对于前期而言，可直接采用 PIO 预置，两种都会说到。&lt;/p>
&lt;h2 id="pio-新建项目">PIO 新建项目
&lt;/h2>&lt;p>点击 &lt;code>New Project&lt;/code> 选择对应板型号，创建即可，该过程首次会下载数据，注意网络环境&lt;/p>
&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/stm32-modern-tools/CreatingPIOProject.png"
loading="lazy"
alt="创建 PIO 项目"
class="responsive-image"
>
&lt;figcaption>创建 PIO 项目&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>其中 &lt;code>Framework&lt;/code> 一项需选择 STM32Cube 以使用板载 ST-Link 进行连接，默认位置 &lt;code>default location&lt;/code> 在默认的 &lt;code>Documents/PlatformIO&lt;/code> 即&amp;quot;文档&amp;quot;文件夹下&lt;/p>
&lt;p>默认文件夹架构如下&lt;/p>
&lt;p>其中 &lt;code>.pio&lt;/code> 与 &lt;code>.vscode&lt;/code> 分别放置 PIO 与 VSCode 相关驱动文件，&lt;code>include&lt;/code>、&lt;code>lib&lt;/code>、&lt;code>src&lt;/code>、&lt;code>test&lt;/code> 分别存放自定义头文件、项目资源/驱动/库、项目代码文件、自动测试脚本&lt;/p>
&lt;p>&lt;code>.pio&lt;/code> 由PlatformIO自动生成和管理，它存放着编译过程中产生的所有中间文件（&lt;code>.o&lt;/code> 文件）、最终生成的固件（&lt;code>firmware.elf&lt;/code>, &lt;code>firmware.bin&lt;/code>），以及为本项目下载的工具链和框架源码&lt;/p>
&lt;p>&lt;code>.vscode&lt;/code> 配置了 PIO 与 VSCode 的集成部分，包括调试与 IntelliSense 的集成等，后者为代码补全显示引用等诸多现代 IDE 功能的必要组成&lt;/p>
&lt;p>&lt;code>test&lt;/code> 文件夹用于存放自动化脚本，假设您写了一个复杂的函数，用来解析GPS模块发来的一长串NMEA数据。您怎么能确定这个函数在各种正常和异常情况下（比如数据丢了几个字节）都能正确工作？传统的方法是把代码烧到板子里，接上GPS模块，然后守着串口看打印信息，费时费力。而单元测试允许您&lt;strong>在不运行整个程序的情况下，单独、自动地测试这一个函数&lt;/strong>。在&lt;code>test&lt;/code>文件夹下，为您想测试的每个功能模块创建一个子文件夹，比如 &lt;code>test/test_gps_parser&lt;/code>。在这个子文件夹里，创建一个C/C++文件（如&lt;code>test_main.cpp&lt;/code>），编写专门的测试代码。您只需要在PlatformIO终端里运行一个命令：&lt;/p>
&lt;p>PlatformIO会自动查找 &lt;code>test&lt;/code> 目录下的所有测试，将&lt;strong>每一个测试都独立编译成一个可执行程序&lt;/strong>，然后：&lt;strong>上传到您的STM32开发板上运行&lt;/strong>，并将测试结果（PASS / FAIL）通过串口返回到电脑上。这被称为&lt;strong>片上测试 (On-Target Test)&lt;/strong>，可以验证与硬件交互的代码。或者，如果您的代码不涉及硬件（比如纯算法），它甚至可以直接在您的&lt;strong>电脑上编译并运行测试&lt;/strong>，速度极快。这被称为&lt;strong>原生测试 (Native Test)&lt;/strong>。&lt;/p>
&lt;h3 id="platformioini-结构">platformio.ini 结构
&lt;/h3>&lt;h4 id="基本构成元素">基本构成元素
&lt;/h4>&lt;p>&lt;strong>&lt;code>[section]&lt;/code>&lt;/strong>: 方括号定义一个配置区块。最重要的区块是 &lt;code>[platformio]&lt;/code>（全局配置）和 &lt;code>[env:NAME]&lt;/code>（特定环境配置）。&lt;/p>
&lt;p>&lt;strong>&lt;code>key = value&lt;/code>&lt;/strong>: 每一行是一个配置项，&lt;code>=&lt;/code> 左边是键（选项名称），右边是值。&lt;/p>
&lt;p>&lt;strong>&lt;code>;&lt;/code>&lt;/strong>: 分号开头表示注释。&lt;/p>
&lt;p>&lt;strong>继承与引用&lt;/strong>: PlatformIO支持在一个环境中引用另一个环境的配置，以减少重复。&lt;/p>
&lt;h4 id="platformio-全局配置区块">&lt;code>[platformio]&lt;/code> 全局配置区块
&lt;/h4>&lt;p>这个区块下的配置项会影响PlatformIO工具本身的行为，而不是某个特定的编译环境。&lt;/p>
&lt;p>&lt;code>default_envs = nucleo_g474re&lt;/code> &lt;strong>功能&lt;/strong>: &lt;strong>(极其有用)&lt;/strong> 定义默认环境。当您的项目有多个&lt;code>[env:...]&lt;/code>区块时，如果您只点击VSCode状态栏的通用&amp;quot;Build&amp;quot;或&amp;quot;Upload&amp;quot;按钮，PlatformIO将只操作这里指定的环境。这完美地解决了我们之前遇到的&amp;quot;16个项目全部失败&amp;quot;的问题。&lt;/p>
&lt;p>&lt;code>src_dir = src&lt;/code> &lt;strong>功能&lt;/strong>: 指定源代码目录的位置，默认为 &lt;code>src&lt;/code>。&lt;/p>
&lt;p>&lt;code>include_dir = include&lt;/code> &lt;strong>功能&lt;/strong>: 指定项目级头文件目录的位置，默认为&lt;code>include&lt;/code>。&lt;/p>
&lt;p>&lt;code>lib_dir = lib&lt;/code> &lt;strong>功能&lt;/strong>: 指定私有库目录的位置，默认为&lt;code>lib&lt;/code>。&lt;/p>
&lt;h4 id="envname-环境配置区块">&lt;code>[env:NAME]&lt;/code> 环境配置区块
&lt;/h4>&lt;p>这是我们99%的工作所在。&lt;code>NAME&lt;/code>是您给这个环境起的名字，比如我们用的&lt;code>nucleo_g474re&lt;/code>。&lt;/p>
&lt;h5 id="1-平台选项-platform-options-必需">1. 平台选项 (Platform Options) [必需]
&lt;/h5>&lt;p>这是定义项目&amp;quot;身份&amp;quot;的基础。&lt;/p>
&lt;p>&lt;code>platform = ststm32&lt;/code> &lt;strong>功能&lt;/strong>: 指定MCU的平台/家族。例如 &lt;code>ststm32&lt;/code>, &lt;code>espressif32&lt;/code>, &lt;code>atmelavr&lt;/code>等。&lt;/p>
&lt;p>&lt;code>board = nucleo_g474re&lt;/code> &lt;strong>功能&lt;/strong>: 指定具体的开发板ID。PlatformIO会根据这个ID自动配置MCU型号、时钟频率、内存大小、上传工具、调试工具等一系列参数。您可以在 &lt;a class="link" href="https://platformio.org/boards" target="_blank" rel="noopener"
>PlatformIO Boards&lt;/a> 找到所有支持的ID。&lt;/p>
&lt;p>&lt;code>framework = stm32cube&lt;/code> &lt;strong>功能&lt;/strong>: 指定使用的软件框架。例如 &lt;code>stm32cube&lt;/code>, &lt;code>arduino&lt;/code>, &lt;code>mbed&lt;/code>。&lt;/p>
&lt;h5 id="2-编译选项-build-options-常用">2. 编译选项 (Build Options) [常用]
&lt;/h5>&lt;p>控制代码如何被编译。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>build_flags =&lt;/code> &lt;strong>功能&lt;/strong>: &lt;strong>(极其强大)&lt;/strong> 向编译器（GCC）传递额外的指令。可以写多行，每行一个指令。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>-O2&lt;/code>: 设置优化等级为2级（默认值）。&lt;code>-Os&lt;/code>为尺寸优化，&lt;code>-O0&lt;/code>为不优化（方便调试）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-D MACRO_NAME&lt;/code>: 定义一个宏，等效于在代码里写&lt;code>#define MACRO_NAME&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-D MACRO_NAME=VALUE&lt;/code>: 定义一个带值的宏。例如 &lt;code>-D BAUD_RATE=9600&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-I path/to/headers&lt;/code>: 添加一个额外的头文件搜索路径。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-Wl,-Map,output.map&lt;/code>: 让链接器生成map文件，用于高级调试。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>src_filter = +&amp;lt;*&amp;gt; -&amp;lt;extra/&amp;gt;&lt;/code> &lt;strong>功能&lt;/strong>: 源代码过滤器。可以精确控制哪些文件参与编译。&lt;code>+&amp;lt; &amp;gt;&lt;/code>表示包含，&lt;code>-&amp;lt; &amp;gt;&lt;/code>表示排除。例如 &lt;code>+&amp;lt;*&amp;gt; -&amp;lt;test/&amp;gt; -&amp;lt;examples/&amp;gt;&lt;/code> 表示编译所有文件，但排除&lt;code>test&lt;/code>和&lt;code>examples&lt;/code>目录下的文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>extra_scripts = pre:my_script.py&lt;/code> &lt;strong>功能&lt;/strong>: (高级) 在编译前(&lt;code>pre:&lt;/code>)或编译后(&lt;code>post:&lt;/code>)执行一个Python脚本，用于实现高度自动化，比如在编译后自动生成固件版本号。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="3-库选项-library-options-核心功能">3. 库选项 (Library Options) [核心功能]
&lt;/h5>&lt;p>管理项目依赖的库。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>lib_deps =&lt;/code> &lt;strong>功能&lt;/strong>: &lt;strong>(PlatformIO的灵魂)&lt;/strong> 指定项目依赖的库。PlatformIO会自动下载、安装并链接它们。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>adafruit/DHT sensor library&lt;/code>: 根据库的 &lt;code>所有者/名称&lt;/code> 从官方库中心查找。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>DHT sensor library@1.3.4&lt;/code>: 指定库的版本号。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>https://github.com/user/repo.git&lt;/code>: 直接从一个Git仓库依赖。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>file://path/to/local/library&lt;/code>: 依赖本地的一个库文件夹。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>lib_ignore = SomeLib, AnotherLib&lt;/code> &lt;strong>功能&lt;/strong>: 明确告诉PlatformIO忽略某些库，以解决可能发生的库冲突。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="4-上传选项-upload-options">4. 上传选项 (Upload Options)
&lt;/h5>&lt;ul>
&lt;li>
&lt;p>&lt;code>upload_protocol = stlink&lt;/code> &lt;strong>功能&lt;/strong>: 指定烧录固件的协议/工具。对于NUCLEO板，&lt;code>stlink&lt;/code>是默认值，通常可以省略。其他可选值如 &lt;code>jlink&lt;/code>, &lt;code>cmsis-dap&lt;/code>, &lt;code>mbed&lt;/code>等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>upload_port = COM3&lt;/code> &lt;strong>功能&lt;/strong>: 在使用串口烧录时（比如Arduino Uno），指定烧录端口。对于ST-LINK则不需要。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>upload_flags =&lt;/code> &lt;strong>功能&lt;/strong>: 向烧录工具传递额外的命令行参数，用于非常特殊的烧录场景。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="5-串口监视器选项-serial-monitor-options">5. 串口监视器选项 (Serial Monitor Options)
&lt;/h5>&lt;ul>
&lt;li>
&lt;p>&lt;code>monitor_speed = 115200&lt;/code> &lt;strong>功能&lt;/strong>: &lt;strong>(即将用到)&lt;/strong> 设置串口监视器的波特率。&lt;strong>必须&lt;/strong>与您代码中UART初始化的波特率严格一致。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>monitor_port = COM3&lt;/code> &lt;strong>功能&lt;/strong>: 手动指定要监听的串口。默认情况下PlatformIO会自动检测。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>monitor_filters = colorize, log2file&lt;/code> &lt;strong>功能&lt;/strong>: (高级) 监视器过滤器。可以在数据被打印出来之前对其进行处理。&lt;code>colorize&lt;/code>可以给输出加上颜色，&lt;code>log2file&lt;/code>可以把串口输出自动保存到文件中。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="6-调试选项-debug-options">6. 调试选项 (Debug Options)
&lt;/h5>&lt;ul>
&lt;li>
&lt;p>&lt;code>debug_tool = stlink&lt;/code> &lt;strong>功能&lt;/strong>: 指定进行硬件调试的工具。NUCLEO板默认为&lt;code>stlink&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>debug_init_break = tbreak main&lt;/code> &lt;strong>功能&lt;/strong>: 设置调试开始时的第一个断点。&lt;code>tbreak main&lt;/code>表示在&lt;code>main&lt;/code>函数入口处设置一个&lt;strong>临时&lt;/strong>断点，程序会在这里停下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>debug_speed = 1800&lt;/code> &lt;strong>功能&lt;/strong>: 设置调试器与目标芯片的通信速度（kHz）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="由-stm32cubemx-创建并导入">由 STM32CubeMX 创建并导入
&lt;/h2>&lt;h1 id="编译与烧录">编译与烧录
&lt;/h1>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/stm32-modern-tools/Button.png"
loading="lazy"
alt="PIO 界面按钮"
class="responsive-image"
>
&lt;figcaption>PIO 界面按钮&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>依次为 PIO Home 主页面、编译、烧录、清除文件、测试、PIO CLI、项目环境&lt;/p>
&lt;p>调试请按 &lt;code>F5&lt;/code>&lt;/p></description></item></channel></rss>