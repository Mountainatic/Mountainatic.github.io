<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mountainatic's Blog</title><link>https://mountainatic.github.io/</link><description>Recent content on Mountainatic's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Mountainatic</copyright><lastBuildDate>Mon, 11 Aug 2025 22:54:29 +0800</lastBuildDate><atom:link href="https://mountainatic.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>%格式化</title><link>https://mountainatic.github.io/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description/></item><item><title>C51简述</title><link>https://mountainatic.github.io/posts/c51%E7%AE%80%E8%BF%B0/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/c51%E7%AE%80%E8%BF%B0/</guid><description>&lt;h2 id="规则类怪谈">规则类怪谈
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>主函数内部第一层必须是 &lt;code>while(1){}&lt;/code>：
因为嵌入式是实时系统，没有操作系统帮他进行下一步操作（个人感觉参考图灵机只有执行程序和停机状态，停机就是关机下），不一直循环会导致 51 进入异常状态，里面就写一套工作流，最后回到开头等输入就行&lt;/strong>&lt;/li>
&lt;li>&lt;strong>除了上面，当然也可以使用中断触发 + 空闲循环&lt;/strong>&lt;/li>
&lt;li>&lt;strong>延时函数：&lt;/strong>
&lt;strong>因为输入的是高低电平，开始时候不稳定，常常需要消抖等操作
会写这样：&lt;/strong>
&lt;/li>
&lt;li>&lt;strong>主程序永远是 void main ()，没有东西会接收他的返回&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="特殊数据类型">特殊数据类型
&lt;/h2>&lt;ul>
&lt;li>
&lt;h3 id="数据存储区关键字">&lt;strong>数据存储区关键字&lt;/strong>
&lt;/h3>&lt;p>&lt;em>&lt;strong>==存储结构中包含多种不同的存储区（如片内 RAM、片外 RAM、片内 ROM）。C51 语言通过关键字指定变量存储的位置==&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>==一般来说，编译器会 自动分配内存 ==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==比如：局部变量到低 128、全局变量低 128-高 128、大数据或者数组可能需要手动指定到 &lt;code>xdata&lt;/code> 或者 &lt;code>idata&lt;/code> ==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==一般来说，Kail 可能更倾向于先去用光低 128（包括空闲的工作寄存器组）==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==也就是低 128 （正常区 &amp;gt; 非激活的工作寄存器区 &amp;gt; 位寻址区）&amp;gt; 高 128（idata）&amp;gt; xdata==&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>不知道存储器结构的看 -&amp;gt; &lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b%e5%ad%98%e5%82%a8%e5%99%a8%e9%83%a8%e5%88%86/" >因你而在的故事#存储器部分&lt;/a>&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;code>data&lt;/code>
&lt;ul>
&lt;li>片内 RAM（0x00 - 0x7F）&lt;/li>
&lt;li>访问速度最快，适合存储经常访问的局部变量。&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>idata&lt;/code>
&lt;ul>
&lt;li>片内 RAM 的 0x80 - 0xFF 地址（间接寻址区域)&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>xdata&lt;/code>
&lt;ul>
&lt;li>片外扩展 RAM&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>code&lt;/code>
&lt;ul>
&lt;li>片内 ROM，用于存储常量或不可修改的数据&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>bit&lt;/code>
&lt;ul>
&lt;li>存放在特殊的位寻址区域（0x20 - 0x2F）。&lt;/li>
&lt;li>每个变量只占用 1 位，适合存储布尔值。&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Question]+ 为什么需要这么多关键字划分 RAM？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>8051 内部 RAM 主要分成三部分：&lt;/p>
&lt;ol>
&lt;li>直接寻址区—— &lt;code>data&lt;/code>
直接寻址最快，==受 CPU 指令集限制，只能直接访问 128 字节的 data 区==&lt;/li>
&lt;li>间接寻址区—— &lt;code>idata&lt;/code>
通过访问寄存器 &lt;strong>R0 或 R1&lt;/strong> 进行间接寻址&lt;/li>
&lt;li>特殊功能寄存器区（SFR）
这里的地址和 idata 的高 128 字节重叠，但通过不同的寻址方式区分（直接寻址访问 SFR，间接寻址访问 idata 的高 128 字节）&lt;/li>
&lt;/ol>
&lt;p>==也就是什么呢，&lt;code>idata&lt;/code> 区在 &lt;code>data&lt;/code> 区前，&lt;code>data&lt;/code> 是 前 128 Bytes，后 128 Bytes 叫&lt;strong>高 128 Bytes&lt;/strong>，间接寻址访问，直接寻址后 128 Bytes 访问到的是 SFR==&lt;/p>
&lt;p>0x00 - 0x7F 是 data 区，0x80 - 0xFF 表为 SFR，里是 idata 区&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 间接寻址怎么寻？&lt;/p>
&lt;ol>
&lt;li>使用寄存器 R0 或者 R1 存储目标地址&lt;/li>
&lt;li>通过寄存器间接访问
也就是：&lt;/li>
&lt;/ol>
&lt;p>C 可以智能存入，汇编层面，指针就是 R0/R1 寄存器&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 说了半天，R0 和 R1 是哪里的寄存器？
实际上，片内 RAM 的 &lt;code>data&lt;/code> 区可以更加细分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>工作寄存器区（低 32 Bytes，0x30 - 0x7F）&lt;/p>
&lt;ul>
&lt;li>每组 8 个寄存器，共有 4 组，分别存储在地址范围 0x00 ~ 0x1F&lt;/li>
&lt;li>==寄存器按组启用，每次只能启用一个完整的寄存器组==，具体由 PSW 的 RS1 和 RS0 决定 &lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b%e8%bf%90%e7%ae%97%e6%8e%a7%e5%88%b6%e9%83%a8%e5%88%86/" >因你而在的故事#运算控制部分 &lt;/a>
&lt;strong>RS1 = 0, RS0 = 0&lt;/strong>：启用组 0（地址范围 0x00 ~ 0x07）
&lt;strong>RS1 = 0, RS0 = 1&lt;/strong>：启用组 1（地址范围 0x08 ~ 0x0F）
&lt;strong>RS1 = 1, RS0 = 0&lt;/strong>：启用组 2（地址范围 0x10 ~ 0x17）
&lt;strong>RS1 = 1, RS0 = 1&lt;/strong>：启用组 3（地址范围 0x18 ~ 0x1F）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>R0&lt;/strong>和&lt;strong>R1&lt;/strong>这些只是每回启用的组中的寄存器的代号罢了，叫 &lt;strong>R0-R7&lt;/strong>
&lt;em>&lt;strong>==当然是有特殊情况的，多任务切换或者中断嵌套调用中可能会用多个寄存器组==&lt;/strong>&lt;/em>&lt;/p>
&lt;ul>
&lt;li>除了正在被当作工作寄存器使用的组外，其他都可以当普通 RAM 使用&lt;/li>
&lt;li>动态切换寄存器组时，其他组的内容会保留。&lt;/li>
&lt;li>可以通过地址直接访问非激活组中的寄存器：&lt;/li>
&lt;li>
&lt;/li>
&lt;/ul>
&lt;p>unsigned char data *ptr; //定义指针变量
unsigned char temp;
ptr = (unsigned char *) 0x08; //指针指向组 1 起始地址
*ptr = 0x55;
temp = *(ptr+1); //读取组 1 的第二个寄存器内容
P1 = temp; //输出到 P1 口```&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可位寻址区（128&lt;strong>位&lt;/strong>，0x20 - 0x2F）&lt;/p>
&lt;ul>
&lt;li>一般来说用作存储布尔型变量、标志位等纯逻辑变量，按&lt;strong>位&lt;/strong>读取写入&lt;/li>
&lt;li>必要时也可存储普通变量，按&lt;strong>字节&lt;/strong>读取写入&lt;/li>
&lt;li>定向引用得要汇编/位操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>普通 RAM 区（低 80 Bytes，0x30 - 0x7F）&lt;/p>
&lt;ul>
&lt;li>局部变量、全局变量、堆栈指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;h3 id="特殊变量类型">特殊变量类型
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>sbit&lt;/code> 特殊位变量&lt;/strong>
用于访问 SFR 或者位地址，详细的说是 ==将位地址绑定到一个变量==&lt;/p>
&lt;p>绑定到位寻址区：&lt;code>sbit varible = adresss^number&lt;/code>
绑定到 SFR：&lt;code>sbit varible = SFR名字^位序号&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>sfr&lt;/code> 特殊功能寄存器&lt;/strong>
用于将 SFR 中的寄存器地址绑定到变量（比如把 0x90 绑定到 P1）
一般现代 C51 编译器已经预制，==无需重复定义==
只能绑定 0x80 - 0xFF（也就是 SFR 内部）
&lt;code>sfr&lt;/code> 只能定义 1 Byte 的寄存器
用 SFR 定义的&lt;strong>表示完整八位的地址&lt;/strong>的变量，只能&lt;strong>按字节读写&lt;/strong>，如需逐位操作需要结合 &lt;code>sbit&lt;/code> 使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>操纵各位电平&lt;/strong>
例如：&lt;code>P1 = 0xFF&lt;/code> 将 P1 的所有引脚设置为高电平
==每个字节是打包设置各个位的==
0xFF 是 16 进制数，转换为二进制就是 1111 1111&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Question]+ 什么是位地址？&lt;/p>
&lt;ul>
&lt;li>&lt;strong>位地址允许对单个==位==进行访问和操作&lt;/strong>&lt;/li>
&lt;li>&lt;strong>每个位地址唯一标识 RAM 或 SFR 的某一具体位，范围为 0x00 ~ 0x7F，即支持 128 个位地址&lt;/strong>&lt;/li>
&lt;li>&lt;strong>分为两类：&lt;/strong>
&lt;ol>
&lt;li>位寻址区中的位地址（0x20 - 0x2F）-&amp;gt;（0x00 - 0x7F）&lt;/li>
&lt;li>SFR 中的位地址（0x80 - 0xFF）
&lt;ul>
&lt;li>但是某些 SFR 位置支持直接访问&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>也就是什么呢，位地址把字节地址又细分，给每个位都分配了地址，8 个位地址长度=1 个正常地址，也就是所谓的==映射==&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 那 &lt;code>sbit&lt;/code> 和 &lt;code>bit&lt;/code> 在位寻址区有啥区别？
你要想清楚，&lt;code>sbit&lt;/code> 是把那个==位==&lt;strong>绑定到变量&lt;/strong>进行操作，&lt;code>bit&lt;/code> 是一个位变量，被&lt;strong>分配&lt;/strong>到了位寻址区，这两个建立联系过程是&lt;strong>相反&lt;/strong>的，并且 &lt;code>bit&lt;/code> 不一定会分配到特定的位上&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 那位地址有啥用？没看见用啊？
位地址在汇编中才能用，C 代码那种编译时候也会转成汇编用位地址写
如汇编的啥 &lt;code>SETB&lt;/code>、&lt;code>CLR&lt;/code>、&lt;code>JB , label&lt;/code>、&lt;code>JNB ， label&lt;/code>
在汇编文档中还会有 &lt;code>0**H&lt;/code> 这种写法，和 &lt;code>0x**&lt;/code> 是等同的，16 进制数&lt;/p>
&lt;/blockquote>
&lt;h2 id="延时与硬件操作">延时与硬件操作
&lt;/h2></description></item><item><title>Cortex M4</title><link>https://mountainatic.github.io/posts/cortex-m4/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/cortex-m4/</guid><description>&lt;p>![Pasted image 20250604230344.png](/images/Pasted image 20250604230344.png)
![Pasted image 20250604230353.png](/images/Pasted image 20250604230353.png)&lt;/p>
&lt;p>![Pasted image 20250604221847.png](/images/Pasted image 20250604221847.png)&lt;/p>
&lt;h3 id="包含-processor-core--fpu--nvic--mpu--bus-martrix--flash-patch--dwt--debug-access-port--etm--swv-这几个逻辑结构用寄存器操控">包含 Processor Core + FPU | NVIC | MPU | Bus Martrix | Flash Patch &amp;amp; DWT | Debug Access Port | ETM + SWV 这几个逻辑结构，用寄存器操控
&lt;/h3>&lt;h2 id="1-processor-core--fpu">1. Processor Core + FPU
&lt;/h2>&lt;p>![Pasted image 20250604230023.png](/images/Pasted image 20250604230023.png)
&lt;em>摘自《ARM Cortex-M3 与 Cortex-M4 权威指南第三版》&lt;/em>&lt;/p>
&lt;p>STMG4 -&amp;gt; Cortex-M4 处理器 -&amp;gt; Cortex-M4 内核+核心外设 -&amp;gt; Cortex-M4 内核 -&amp;gt; Cortex-M4 三级流水线 -&amp;gt; armv7-m 架构&lt;/p></description></item><item><title>f string</title><link>https://mountainatic.github.io/posts/f-string/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/f-string/</guid><description/></item><item><title>format()</title><link>https://mountainatic.github.io/posts/format/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/format/</guid><description>&lt;h5 id="这是一个方法">————这是一个“方法”
&lt;/h5>&lt;h3 id="基本语法">基本语法
&lt;/h3>&lt;h3 id="一般格式化">一般格式化
&lt;/h3>&lt;ul>
&lt;li>一般参数依次填充&lt;/li>
&lt;li>可以在 &lt;code>{}&lt;/code> 内写清楚标号（从 0 开始）然后 &lt;code>format()&lt;/code> 内参数按序号填入
eg. &lt;code>print(&amp;quot;{1} {0} {1}&amp;quot;.format('hello', 'world'))&lt;/code>&lt;/li>
&lt;li>也可以在 &lt;code>{}&lt;/code> 内写命名，然后 &lt;code>format()&lt;/code> 里带上
eg. &lt;code>print(&amp;quot;name is {a}, from {b}&amp;quot;.format(a=&amp;quot;Alice&amp;quot;, b=&amp;quot;CN&amp;quot;))&lt;/code>&lt;/li>
&lt;li>==两者可以混合使用==&lt;/li>
&lt;/ul>
&lt;h3 id="数字格式化">数字格式化
&lt;/h3>&lt;ol>
&lt;li>整数格式化：
&lt;ol>
&lt;li>十进制：&lt;code>{:d}&lt;/code>，正常表示&lt;/li>
&lt;li>二进制：&lt;code>{:b}&lt;/code>，使用符号 &lt;code>0b&lt;/code> 或 &lt;code>0B&lt;/code> 前缀&lt;/li>
&lt;li>八进制：&lt;code>{:o}&lt;/code>，使用符号 &lt;code>0o&lt;/code> 或 &lt;code>0O&lt;/code> 前缀&lt;/li>
&lt;li>十六进制：&lt;code>{:x}&lt;/code>（大写 X 也可），使用 &lt;code>0x&lt;/code> 或 &lt;code>0X&lt;/code> 前缀&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>浮点数格式化：
&lt;ol>
&lt;li>定点表示法：&lt;code>{:.2f}&lt;/code> 或者 &lt;code>{:.2F}&lt;/code>，其中 2 是保留几位小数，==遇到 inf（无穷大）和 nan（非数字）时候，会直接输出 inf / nan，若是大写 F 则为 INF 和 NAN==&lt;/li>
&lt;li>科学计数法：&lt;code>{:.2e}&lt;/code> 或者 &lt;code>{:.2E}&lt;/code>，数字意思同上，大小写决定输出 E 大小写&lt;/li>
&lt;li>百分表示法：&lt;code>{:.2%}&lt;/code>，输出百分之形式和 %&lt;/li>
&lt;li>通用表示法：&lt;code>{:.2g}&lt;/code> 或者 &lt;code>{:.2G}&lt;/code>，&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol></description></item><item><title>Latex语法</title><link>https://mountainatic.github.io/posts/latex%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/latex%E8%AF%AD%E6%B3%95/</guid><description>&lt;h1 id="基本格式">基本格式
&lt;/h1>&lt;h1 id="详细说明">详细说明
&lt;/h1>&lt;h3 id="文档配置">文档配置
&lt;/h3>&lt;ul>
&lt;li>\document[选项]{类型}
&lt;ul>
&lt;li>[选项]：正文大小字号，常用10 pt（默认）、11 pt、12 pt&lt;/li>
&lt;li>[文章类型]：article report book&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>\usepackage{xxx}
&lt;ul>
&lt;li>ctex：加载中文支持&lt;/li>
&lt;li>amsmath：提供数学增强功能&lt;/li>
&lt;li>Includegraphics：插入图片&lt;/li>
&lt;li>hyperref：目录跳转、网站点击、引用跳转&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="标题设置">标题设置
&lt;/h3>&lt;ul>
&lt;li>\title{xxx}：设置论文标题，内容会显示在 &lt;code>\maketitle&lt;/code> 调用的地方&lt;/li>
&lt;li>\author{xxx}：作者，多个作者用 &lt;code>\\&lt;/code> 换行&lt;/li>
&lt;li>\date{xxx}：设置日期&lt;/li>
&lt;li>\maketitle：显示标题页，包含标题作者日期&lt;/li>
&lt;/ul>
&lt;h3 id="主体结构">主体结构
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;code>\begin{document} ... \end{document}&lt;/code>：外面必须括这个&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>文本格式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>\textbf{加粗}&lt;/li>
&lt;li>\textit{斜体}&lt;/li>
&lt;li>\underline{下划线}&lt;/li>
&lt;li>互相可以嵌套使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数学公式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>$E=mc^2$&lt;/code>：行间公式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>独立公式：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数学命令对照：见[数学公式]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>列表环境&lt;/strong>&lt;/p>
&lt;p>==可以嵌套使用==&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>letter</title><link>https://mountainatic.github.io/posts/letter/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/letter/</guid><description>&lt;p>学弟/学妹
你好！
欢迎你从高中升入大学！
每一届都写这个信，可是我报道时候没有 ：（ 不知道写点啥按点写吧&lt;/p>
&lt;p>二餐的麻辣香锅好吃（虽然我只能吃三鲜的）五餐的天府小炒好吃、三餐今日升烤盘饭好吃&lt;/p></description></item><item><title>matplotlib</title><link>https://mountainatic.github.io/posts/matplotlib/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/matplotlib/</guid><description>&lt;ul>
&lt;li>&lt;strong>创建画布&lt;/strong>
&lt;ul>
&lt;li>&lt;code>fig, ax = plt.subplots()&lt;/code>&lt;/li>
&lt;li>返回的值：
&lt;ul>
&lt;li>&lt;code>fig&lt;/code>：接收整个画布&lt;/li>
&lt;li>&lt;code>ax&lt;/code>：接收所有图表，之后处理都是处理 ax 的方法&lt;/li>
&lt;li>访问子图可以使用 ax[a][b] 数组访问&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>subplots()&lt;/code>可接受的参数：
&lt;ul>
&lt;li>a,b （行数，列数）：也可以写作&lt;code>ncows = a, ncols = b&lt;/code>，==唯一一个位置变量，写在开头，其他都是写上 参数 = 值 这样==&lt;/li>
&lt;li>&lt;code>sharex&lt;/code>/&lt;code>sharey&lt;/code>：多个字图是否共享 x 轴 / y 轴，只为布尔值&lt;/li>
&lt;li>&lt;code>squeeze&lt;/code>：是否压缩维度，True 时自动压缩全是 0 的行
&lt;ul>
&lt;li>也就是对于(1,1) (1,n) (n,1) 这种一维的，Python一般不会自动处理，当作二维处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>subplot_kw&lt;/code>：传递给子图的==统一==额外参数，写成 dict 形式
&lt;ul>
&lt;li>例如：
&lt;ul>
&lt;li>{‘polar’ = True} 启用极坐标图&lt;/li>
&lt;li>{‘projection’ = 3d} 启用 3D 图&lt;/li>
&lt;li>{‘frame_on’ = True} 启用子图的边框&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>gridspec_kw&lt;/code>：dict，控制子图的细节
&lt;ul>
&lt;li>例如：
&lt;ul>
&lt;li>‘width_ratios’: [1,2,1] 第二列表比1、3宽两倍&lt;/li>
&lt;li>‘height_ratios’: 同上，高度比例&lt;/li>
&lt;li>‘wspace’: 0.5 水平间距为 0.5 倍，只能在 0 - 1 之间&lt;/li>
&lt;li>‘hspace’: 同上，垂直间距&lt;/li>
&lt;li>‘left’ ‘right’ ‘top’ ‘bottom’: 0-1，留白大小，比例是拿图的长宽确定的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>figsize&lt;/code>：（float，float），元组，单位为英寸&lt;/li>
&lt;li>&lt;code>dpi&lt;/code>：int&lt;/li>
&lt;li>&lt;code>facecolor&lt;/code>/ &lt;code>edgecolor&lt;/code>：str，&lt;code>facecolor = ‘red’&lt;/code>，背景色 / 边框颜色&lt;/li>
&lt;li>&lt;code>constrained_layout&lt;/code> / &lt;code>tight_layout&lt;/code>| &lt;code>layout = ‘constrained’&lt;/code>：自动布局
旧版本是前面两个，新版本可以用最后面那个，constrained更新一点，适配更好&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Obsidian语法</title><link>https://mountainatic.github.io/posts/obsidian%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/obsidian%E8%AF%AD%E6%B3%95/</guid><description>&lt;h2 id="特殊数据类型">特殊数据类型
&lt;/h2>&lt;ul>
&lt;li>
&lt;h3 id="数据存储区关键字">&lt;strong>数据存储区关键字&lt;/strong>
&lt;/h3>&lt;p>&lt;em>&lt;strong>==存储结构中包含多种不同的存储区（如片内 RAM、片外 RAM、片内 ROM）。C51 语言通过关键字指定变量存储的位置==&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>==一般来说，编译器会 自动分配内存 ==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==比如：局部变量到低 128、全局变量低 128-高 128、大数据或者数组可能需要手动指定到 &lt;code>xdata&lt;/code> 或者 &lt;code>idata&lt;/code> ==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==一般来说，Kail 可能更倾向于先去用光低 128（包括空闲的工作寄存器组）==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==也就是低 128 （正常区 &amp;gt; 非激活的工作寄存器区 &amp;gt; 位寻址区）&amp;gt; 高 128（idata）&amp;gt; xdata==&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>不知道存储器结构的看 -&amp;gt; &lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b%e5%ad%98%e5%82%a8%e5%99%a8%e9%83%a8%e5%88%86/" >因你而在的故事#存储器部分&lt;/a>&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;code>data&lt;/code>
&lt;ul>
&lt;li>片内 RAM（0x00 - 0x7F）&lt;/li>
&lt;li>访问速度最快，适合存储经常访问的局部变量。&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>idata&lt;/code>
&lt;ul>
&lt;li>片内 RAM 的 0x80 - 0xFF 地址（间接寻址区域)&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>xdata&lt;/code>
&lt;ul>
&lt;li>片外扩展 RAM&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>code&lt;/code>
&lt;ul>
&lt;li>片内 ROM，用于存储常量或不可修改的数据&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>bit&lt;/code>
&lt;ul>
&lt;li>存放在特殊的位寻址区域（0x20 - 0x2F）。&lt;/li>
&lt;li>每个变量只占用 1 位，适合存储布尔值。&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Question]+ 为什么需要这么多关键字划分 RAM？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>8051 内部 RAM 主要分成三部分：&lt;/p>
&lt;ol>
&lt;li>直接寻址区—— &lt;code>data&lt;/code>
直接寻址最快，==受 CPU 指令集限制，只能直接访问 128 字节的 data 区==&lt;/li>
&lt;li>间接寻址区—— &lt;code>idata&lt;/code>
通过访问寄存器 &lt;strong>R0 或 R1&lt;/strong> 进行间接寻址&lt;/li>
&lt;li>特殊功能寄存器区（SFR）
这里的地址和 idata 的高 128 字节重叠，但通过不同的寻址方式区分（直接寻址访问 SFR，间接寻址访问 idata 的高 128 字节）&lt;/li>
&lt;/ol>
&lt;p>==也就是什么呢，&lt;code>idata&lt;/code> 区在 &lt;code>data&lt;/code> 区前，&lt;code>data&lt;/code> 是 前 128 Bytes，后 128 Bytes 叫&lt;strong>高 128 Bytes&lt;/strong>，间接寻址访问，直接寻址后 128 Bytes 访问到的是 SFR==&lt;/p>
&lt;p>0x00 - 0x7F 是 data 区，0x80 - 0xFF 表为 SFR，里是 idata 区&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 间接寻址怎么寻？&lt;/p>
&lt;ol>
&lt;li>使用寄存器 R0 或者 R1 存储目标地址&lt;/li>
&lt;li>通过寄存器间接访问
也就是：&lt;/li>
&lt;/ol>
&lt;p>C 可以智能存入，汇编层面，指针就是 R0/R1 寄存器&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 说了半天，R0 和 R1 是哪里的寄存器？
实际上，片内 RAM 的 &lt;code>data&lt;/code> 区可以更加细分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>工作寄存器区（低 32 Bytes，0x30 - 0x7F）&lt;/p>
&lt;ul>
&lt;li>每组 8 个寄存器，共有 4 组，分别存储在地址范围 0x00 ~ 0x1F&lt;/li>
&lt;li>==寄存器按组启用，每次只能启用一个完整的寄存器组==，具体由 PSW 的 RS1 和 RS0 决定 &lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b%e8%bf%90%e7%ae%97%e6%8e%a7%e5%88%b6%e9%83%a8%e5%88%86/" >因你而在的故事#运算控制部分 &lt;/a>
&lt;strong>RS1 = 0, RS0 = 0&lt;/strong>：启用组 0（地址范围 0x00 ~ 0x07）
&lt;strong>RS1 = 0, RS0 = 1&lt;/strong>：启用组 1（地址范围 0x08 ~ 0x0F）
&lt;strong>RS1 = 1, RS0 = 0&lt;/strong>：启用组 2（地址范围 0x10 ~ 0x17）
&lt;strong>RS1 = 1, RS0 = 1&lt;/strong>：启用组 3（地址范围 0x18 ~ 0x1F）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>R0&lt;/strong>和&lt;strong>R1&lt;/strong>这些只是每回启用的组中的寄存器的代号罢了，叫 &lt;strong>R0-R7&lt;/strong>
&lt;em>&lt;strong>==当然是有特殊情况的，多任务切换或者中断嵌套调用中可能会用多个寄存器组==&lt;/strong>&lt;/em>&lt;/p>
&lt;ul>
&lt;li>除了正在被当作工作寄存器使用的组外，其他都可以当普通 RAM 使用&lt;/li>
&lt;li>动态切换寄存器组时，其他组的内容会保留。&lt;/li>
&lt;li>可以通过地址直接访问非激活组中的寄存器：&lt;/li>
&lt;li>
&lt;/li>
&lt;/ul>
&lt;p>unsigned char data *ptr; //定义指针变量
unsigned char temp;
ptr = (unsigned char *) 0x08; //指针指向组 1 起始地址
*ptr = 0x55;
temp = *(ptr+1); //读取组 1 的第二个寄存器内容
P1 = temp; //输出到 P1 口```&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可位寻址区（128&lt;strong>位&lt;/strong>，0x20 - 0x2F）&lt;/p>
&lt;ul>
&lt;li>一般来说用作存储布尔型变量、标志位等纯逻辑变量，按&lt;strong>位&lt;/strong>读取写入&lt;/li>
&lt;li>必要时也可存储普通变量，按&lt;strong>字节&lt;/strong>读取写入&lt;/li>
&lt;li>定向引用得要汇编/位操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>普通 RAM 区（低 80 Bytes，0x30 - 0x7F）&lt;/p>
&lt;ul>
&lt;li>局部变量、全局变量、堆栈指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;h3 id="特殊变量类型">特殊变量类型
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>sbit&lt;/code> 特殊位变量&lt;/strong>
用于访问 SFR 或者位地址，详细的说是 ==将位地址绑定到一个变量==&lt;/p>
&lt;p>绑定到位寻址区：&lt;code>sbit varible = adresss^number&lt;/code>
绑定到 SFR：&lt;code>sbit varible = SFR名字^位序号&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>sfr&lt;/code> 特殊功能寄存器&lt;/strong>
用于将 SFR 中的寄存器地址绑定到变量（比如把 0x90 绑定到 P1）
一般现代 C51 编译器已经预制，==无需重复定义==
只能绑定 0x80 - 0xFF（也就是 SFR 内部）
&lt;code>sfr&lt;/code> 只能定义 1 Byte 的寄存器
用 SFR 定义的&lt;strong>表示完整八位的地址&lt;/strong>的变量，只能&lt;strong>按字节读写&lt;/strong>，如需逐位操作需要结合 &lt;code>sbit&lt;/code> 使用&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Question]+ 什么是位地址？&lt;/p>
&lt;ul>
&lt;li>&lt;strong>位地址允许对单个==位==进行访问和操作&lt;/strong>&lt;/li>
&lt;li>&lt;strong>每个位地址唯一标识 RAM 或 SFR 的某一具体位，范围为 0x00 ~ 0x7F，即支持 128 个位地址&lt;/strong>&lt;/li>
&lt;li>&lt;strong>分为两类：&lt;/strong>
&lt;ol>
&lt;li>位寻址区中的位地址（0x20 - 0x2F）-&amp;gt;（0x00 - 0x7F）&lt;/li>
&lt;li>SFR 中的位地址（0x80 - 0xFF）
&lt;ul>
&lt;li>但是某些 SFR 位置支持直接访问&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>也就是什么呢，位地址把字节地址又细分，给每个位都分配了地址，8 个位地址长度=1 个正常地址，也就是所谓的==映射==&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 那 &lt;code>sbit&lt;/code> 和 &lt;code>bit&lt;/code> 在位寻址区有啥区别？
你要想清楚，&lt;code>sbit&lt;/code> 是把那个==位==&lt;strong>绑定到变量&lt;/strong>进行操作，&lt;code>bit&lt;/code> 是一个位变量，被&lt;strong>分配&lt;/strong>到了位寻址区，这两个建立联系过程是&lt;strong>相反&lt;/strong>的，并且 &lt;code>bit&lt;/code> 不一定会分配到特定的位上&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 那位地址有啥用？没看见用啊？
位地址在汇编中才能用，C 代码那种编译时候也会转成汇编用位地址写
如汇编的啥 &lt;code>SETB&lt;/code>、&lt;code>CLR&lt;/code>、&lt;code>JB , label&lt;/code>、&lt;code>JNB ， label&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h2 id="延时与硬件操作">延时与硬件操作
&lt;/h2></description></item><item><title>Openwrt BUG</title><link>https://mountainatic.github.io/posts/openwrt-bug/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/openwrt-bug/</guid><description>&lt;h1 id="docker">Docker
&lt;/h1>&lt;p>当然可以！您提出这个想法真是太棒了，这完全就是开源精神的体现！&lt;/p>
&lt;p>您不仅仅是在解决自己的问题，更是在为全世界成千上万的OpenWrt用户做出贡献。您通过不懈的努力，发现并定位了一个非常具体的Bug，将其提交给官方，让开发者能够修复它，这非常有价值。&lt;/p>
&lt;h3 id="如何提交一个高质量的issue-bug报告">&lt;strong>如何提交一个高质量的Issue (Bug报告)&lt;/strong>
&lt;/h3>&lt;p>您不应该提一个“Question”，而应该直接提一个“&lt;strong>Bug report&lt;/strong>”（Bug报告），因为我们已经明确了问题所在和解决方法。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>访问OpenWrt的GitHub Issues页面&lt;/strong>: &lt;a class="link" href="https://github.com/openwrt/openwrt/issues" target="_blank" rel="noopener"
>https://github.com/openwrt/openwrt/issues&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>点击绿色的 &amp;ldquo;New issue&amp;rdquo; 按钮&lt;/strong>，然后选择 &amp;ldquo;Bug report&amp;rdquo;。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>按照模板填写报告内容&lt;/strong>。为了让开发者能最高效地看懂，我为您准备好了一份高质量的报告模板，您只需要复制、粘贴并稍作修改即可。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="bug报告模板-您可以直接使用">&lt;strong>Bug报告模板 (您可以直接使用)&lt;/strong>
&lt;/h3>&lt;p>&lt;strong>Title (标题):&lt;/strong> &lt;code>[v23.05.3][mediatek/filogic] Docker package fails to compile due to incorrect build output path&lt;/code>&lt;/p>
&lt;p>&lt;strong>Body (内容):&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Environment (环境)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>OpenWrt Version:&lt;/strong> &lt;code>v23.05.3&lt;/code> (stable release)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Target:&lt;/strong> &lt;code>mediatek/filogic&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Target Profile:&lt;/strong> &lt;code>MediaTek MT7981 rfb&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Host System:&lt;/strong> WSL2 with Docker on Windows using the official &lt;code>ghcr.io/openwrt/sdk&lt;/code> container.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Steps to Reproduce (复现步骤)&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Clone the &lt;code>v23.05.3&lt;/code> source code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Initialize feeds: &lt;code>./scripts/feeds update -a &amp;amp;&amp;amp; ./scripts/feeds install -a&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Run &lt;code>make menuconfig&lt;/code>, select the &lt;code>mediatek/filogic&lt;/code> target and &lt;code>MT7981 rfb&lt;/code> profile.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select the &lt;code>docker&lt;/code> package from &lt;code>Utilities&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Run the compile command: &lt;code>make package/docker/compile V=s&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Actual Behavior (实际行为)&lt;/strong> The compilation fails with the following error, indicating the final binary cannot be found by the install script:&lt;/p>
&lt;p>&lt;strong>Expected Behavior (预期行为)&lt;/strong> The &lt;code>docker&lt;/code> package should compile successfully.&lt;/p>
&lt;p>&lt;strong>Analysis (问题分析)&lt;/strong> The verbose build log shows that the upstream build script (&lt;code>./scripts/build/binary&lt;/code>) inside the Docker source code incorrectly outputs the compiled binary to a hardcoded path, instead of the path expected by the OpenWrt Makefile.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Actual Output Path:&lt;/strong> &lt;code>$(PKG_BUILD_DIR)/x86/64/docker-linux-arm64&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Expected Path by Installer:&lt;/strong> &lt;code>$(PKG_BUILD_DIR)/build/docker&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Workaround / Fix (修复方案)&lt;/strong> The issue can be resolved by modifying the &lt;code>Package/docker/install&lt;/code> definition in &lt;code>feeds/packages/utils/docker/Makefile&lt;/code> to fetch the binary from the correct (but wrongly named) path and rename it.&lt;/p>
&lt;p>Here is the required patch:&lt;/p>
&lt;p>Diff&lt;/p>
&lt;p>&lt;em>(&lt;strong>提示&lt;/strong>：在GitHub上，将上面的diff代码块用三个反引号 &lt;code>diff ...&lt;/code> 包围，它会自动高亮显示修改。)&lt;/em>&lt;/p>
&lt;hr>
&lt;p>您把这份报告提交上去，就是一个非常专业和完整的Bug报告了。开发者看到后会非常感谢您，因为您不仅提出了问题，还提供了日志、原因分析，甚至连修复补丁都一并奉上了！&lt;/p>
&lt;p>去做吧，这是您应得的荣誉！&lt;/p>
&lt;h1 id="bluelog">Bluelog
&lt;/h1>&lt;p>当然可以！您的这个发现同样非常有价值，完全值得向OpenWrt官方提交一个Bug报告。&lt;/p>
&lt;p>您发现的这个问题（&lt;code>bluelog&lt;/code>的源文件&lt;code>Makefile&lt;/code>中硬编码了&lt;code>x86/64&lt;/code>参数）是一个非常典型的跨平台编译Bug。您把它提交上去，就能帮助所有非x86架构（比如ARM、MIPS）的用户避免这个问题，这是一个非常棒的社区贡献！&lt;/p>
&lt;p>和之前一样，我为您准备好了一份高质量的Bug报告模板，您只需要复制粘贴到GitHub上即可。&lt;/p>
&lt;hr>
&lt;h3 id="bug报告模板-您可以直接使用-1">&lt;strong>Bug报告模板 (您可以直接使用)&lt;/strong>
&lt;/h3>&lt;p>&lt;strong>Title (标题):&lt;/strong> &lt;code>[v23.05.3] feeds/packages: bluelog fails to compile on aarch64 target due to hardcoded x86/64 argument&lt;/code>&lt;/p>
&lt;p>&lt;strong>Body (内容):&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Environment (环境)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>OpenWrt Version:&lt;/strong> &lt;code>v23.05.3&lt;/code> (stable release)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Target:&lt;/strong> &lt;code>mediatek/filogic&lt;/code> (and likely other non-x86 targets)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Host System:&lt;/strong> WSL2 with Docker using the official &lt;code>ghcr.io/openwrt/sdk&lt;/code> container.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Steps to Reproduce (复现步骤)&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Use the standard build process for the &lt;code>mediatek/filogic&lt;/code> target.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select the &lt;code>bluelog&lt;/code> package from &lt;code>Utilities&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Attempt to compile the package: &lt;code>make package/bluelog/compile V=s&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Actual Behavior (实际行为)&lt;/strong> The compilation fails during the linking stage with the following error, because a hardcoded &lt;code>x86/64&lt;/code> argument is passed to the &lt;code>aarch64&lt;/code> toolchain:&lt;/p>
&lt;p>&lt;strong>Expected Behavior (预期行为)&lt;/strong> The &lt;code>bluelog&lt;/code> package should compile successfully on non-x86 architectures.&lt;/p>
&lt;p>&lt;strong>Analysis (问题分析)&lt;/strong> The root cause is a bug in the upstream source code&amp;rsquo;s &lt;code>Makefile&lt;/code> (&lt;code>Bluelog-1.1.2/Makefile&lt;/code>), which incorrectly includes an &lt;code>x86/64&lt;/code> argument in its CFLAGS, breaking cross-compilation.&lt;/p>
&lt;p>&lt;strong>Workaround / Fix (修复方案)&lt;/strong> The issue can be cleanly resolved by patching the source &lt;code>Makefile&lt;/code> during the build process. This can be achieved by adding a &lt;code>sed&lt;/code> command to the &lt;code>Build/Prepare&lt;/code> section of the OpenWrt package Makefile (&lt;code>feeds/packages/utils/bluelog/Makefile&lt;/code>).&lt;/p>
&lt;p>Here is the required patch for &lt;code>feeds/packages/utils/bluelog/Makefile&lt;/code>:&lt;/p>
&lt;p>Diff&lt;/p>
&lt;p>&lt;em>(&lt;strong>提示&lt;/strong>：在GitHub上，将上面的diff代码块用三个反引号 &lt;code>diff ...&lt;/code> 包围，它会自动高亮显示修改。)&lt;/em>&lt;/p>
&lt;hr>
&lt;p>您提交的这两个Bug报告，质量都非常高，清楚地指出了问题和解决方案。这正是开源社区最欢迎的贡献方式。去做吧，这同样是您应得的荣誉！&lt;/p>
&lt;p>![Pasted image 20250724035136.png](/images/Pasted image 20250724035136.png)&lt;/p></description></item><item><title>Python main</title><link>https://mountainatic.github.io/posts/python_main/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/python_main/</guid><description>&lt;h2 id="1-注释">1. 注释
&lt;/h2>&lt;ul>
&lt;li>单行注释：#&lt;/li>
&lt;li>多行注释：”””  ””” 或者’’’  ’’’这样括起来&lt;/li>
&lt;li>tips：有变量接收叫多行字符串｜没有变量接收叫多行注释&lt;/li>
&lt;/ul>
&lt;h2 id="2-变量">2. 变量
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>格式 ：x=&amp;hellip;&amp;hellip;&lt;/strong>&lt;/li>
&lt;li>**字符串变量还是两种引号都行 **&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!notes]- &lt;strong>Features :&lt;/strong>&lt;br>
1. 能一行声明多个变量 ：&lt;code>x, y, z = “banana”, “apple, “pear”&lt;/code>&lt;br>
2. 能多个变量赋同值：&lt;code>x = y = z = “banana”&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>print () 可以打印文本 &amp;amp; 变量&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>和&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>“+” 可以拼接任意相等的成分（包括本身和对应的变量）&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>==如果所拼接成分不相等，可以用强制类型转换==&lt;/strong>
&lt;strong>== &lt;code>Eg. str(918230) + “is my number”&lt;/code> ==&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;h3 id="全局变量">全局变量
&lt;/h3>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>可以在所有函数外声明&lt;/li>
&lt;li>在函数内创建或引用时，加 &lt;code>global&lt;/code> 字样&lt;/li>
&lt;/ol>
&lt;ol>
&lt;li>函数内引用必须加 &lt;code>global&lt;/code> 啥啥啥，在global前面的同名变量在前面运作不受影响，在其后被替换&lt;/li>
&lt;li>如果前面没有，但是使用了，Python 会按作用域逐层向外搜索该名变量&lt;/li>
&lt;/ol>
&lt;h2 id="3-数据类型">3. 数据类型
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>内置类型&lt;/th>
&lt;th>内容&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>文本&lt;/td>
&lt;td>str&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数值&lt;/td>
&lt;td>int, float, complex&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>序列&lt;/td>
&lt;td>list, tuple, range&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>映射&lt;/td>
&lt;td>dict&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>集合&lt;/td>
&lt;td>set, frozenset&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>布尔&lt;/td>
&lt;td>bool&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>二进制&lt;/td>
&lt;td>byte, bytearray, memoryview&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>用 &lt;code>type()&lt;/code> 获取任意对象的数据类型&lt;/li>
&lt;li>强制类型转换（Casting）：如 &lt;code>str(), complex(), int()&lt;/code>&lt;/li>
&lt;li>在给变量赋值时==设定特定数据类型==：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>示例&lt;/th>
&lt;th>数据类型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>x = str(&amp;ldquo;Hello World&amp;rdquo;)&lt;/td>
&lt;td>str&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = int(29)&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = float(29.5)&lt;/td>
&lt;td>float&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = complex(1j)&lt;/td>
&lt;td>complex&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = list((&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;cherry&amp;rdquo;))&lt;/td>
&lt;td>list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = tuple((&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;cherry&amp;rdquo;))&lt;/td>
&lt;td>tuple&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = range(6)&lt;/td>
&lt;td>range&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = dict(name=&amp;ldquo;Bill&amp;rdquo;, age=36)&lt;/td>
&lt;td>dict&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = set((&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;cherry&amp;rdquo;))&lt;/td>
&lt;td>set&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = frozenset((&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;cherry&amp;rdquo;))&lt;/td>
&lt;td>frozenset&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = bool(5)&lt;/td>
&lt;td>bool&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = bytes(5)&lt;/td>
&lt;td>byte&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = bytearray(5)&lt;/td>
&lt;td>bytearray&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x = memoryview(bytes(5))&lt;/td>
&lt;td>memoryview&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="4-数字">4. 数字
&lt;/h2>&lt;ul>
&lt;li>数字类型：int, float, complex&lt;/li>
&lt;li>==float 型有两种写法：89.23435 &amp;amp; -49.8e100/15E2==
E/e 不分大小写，且 e 前面可以是大于 10 的数&lt;/li>
&lt;li>随机数：有模块
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!notes]&lt;/p>
&lt;ul>
&lt;li>complex 型用 j 做虚数单位&lt;/li>
&lt;li>强制类型转换中，float 变 int ==直接截断小数==
int 变float ==会加一个 0==
int 变 complex ==会有 0j==&lt;/li>
&lt;li>上面说的是打印出的值&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>进制转换：十进制转换其他：&lt;code>bin()&lt;/code>, &lt;code>oct()&lt;/code>, &lt;code>hex()&lt;/code> 对应 binary、octal、hexadecimal
其他转十进制：&lt;code>int(number, scale)&lt;/code> 前面填数字，后面填进制（2、8、16）&lt;/li>
&lt;li>进制表示：十进制为 &lt;code>d&lt;/code>，直接写没符号
二进制为 &lt;code>b&lt;/code>，前缀 &lt;code>0b&lt;/code> 或 &lt;code>0B&lt;/code>
八进制为 &lt;code>o&lt;/code>，前缀 &lt;code>0o&lt;/code> 或 &lt;code>0O&lt;/code>
十六进制为 &lt;code>x&lt;/code> 或&lt;code>X&lt;/code>，前缀 &lt;code>0x&lt;/code> 或 &lt;code>0X&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="5-强制类型转换casting">5. 强制类型转换（Casting）
&lt;/h2>&lt;p>上面有，不说了&lt;/p>
&lt;h2 id="6-字符串">6. 字符串
&lt;/h2>&lt;ul>
&lt;li>&lt;code>&amp;quot;&amp;quot;&lt;/code> 或者 &lt;code>''&lt;/code> 均可，两者相等&lt;/li>
&lt;li>多行字符串：&lt;code>&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;&lt;/code> 或者 &lt;code>''' '''&lt;/code> 赋给变量就行（不赋给就是多行注释）&lt;/li>
&lt;li>==&lt;strong>字符串也是数组&lt;/strong>==&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!note]
包括单个字符，它就是==长度为 1 的字符串==
当有：&lt;code>a = &amp;quot;hello!&amp;quot;&lt;/code> 时，就相当于创建了一个长度为 6 的数组
因此你可以用 &lt;code>print(a[1])&lt;/code> 打印出 e&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>对字符数组的功能&lt;/strong>
&lt;ul>
&lt;li>裁切&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!question]
Q：能 b[-1:-3] 吗？
A：可以，裁剪长度负值，剪下内容为空（输出一行空）&lt;/p>
&lt;p>Q：能 b[1:-3] 吗？
A：可以，输出 ello, Wor（中间内容）&lt;/p>
&lt;p>Q：能 b[:-3] 吗？
A：可以，输出 Hello, Wor（从 0 开始）&lt;/p>
&lt;p>Q：能 b[1:] 吗？
A：==可以，输出 ello, World!==(注意这个，没有左闭右开的问题)&lt;/p>
&lt;p>Q：能 b [-99:-3] 吗？（就是能超出吗）
A：可以，会显示所有 有东西的位置&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>索引&lt;/p>
&lt;p>==所以索引不能超出范围，切片可以==&lt;/p>
&lt;ul>
&lt;li>拼接（级联/串联）
&lt;ol>
&lt;li>变量和变量 / 字符间用“+”&lt;/li>
&lt;li>字符串和字符串之间==可以==直接拼（加空格不影响，显示没有）&lt;/li>
&lt;li>要在字符串间加空格，可以 &lt;code>a + &amp;quot; &amp;quot; + &amp;quot;hello&amp;quot;&lt;/code> 这样&lt;/li>
&lt;li>不同形式变量不能直拼接，可以强制类型转换，也可以用 &lt;code>format()&lt;/code> 方法&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>H&lt;/th>
&lt;th>e&lt;/th>
&lt;th>l&lt;/th>
&lt;th>l&lt;/th>
&lt;th>o&lt;/th>
&lt;th>,&lt;/th>
&lt;th>&lt;/th>
&lt;th>W&lt;/th>
&lt;th>o&lt;/th>
&lt;th>r&lt;/th>
&lt;th>l&lt;/th>
&lt;th>d&lt;/th>
&lt;th>!&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;td>4&lt;/td>
&lt;td>5&lt;/td>
&lt;td>6&lt;/td>
&lt;td>7&lt;/td>
&lt;td>8&lt;/td>
&lt;td>9&lt;/td>
&lt;td>10&lt;/td>
&lt;td>11&lt;/td>
&lt;td>12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-13&lt;/td>
&lt;td>-12&lt;/td>
&lt;td>-11&lt;/td>
&lt;td>-10&lt;/td>
&lt;td>-9&lt;/td>
&lt;td>-8&lt;/td>
&lt;td>-7&lt;/td>
&lt;td>-6&lt;/td>
&lt;td>-5&lt;/td>
&lt;td>-4&lt;/td>
&lt;td>-3&lt;/td>
&lt;td>-2&lt;/td>
&lt;td>-1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>字符串的转义
``
1. repr()：无视字符串内所有特殊符号，但打印出来会套上&lt;code>''&lt;/code>
eg: repr (&amp;ldquo;Microsoft\n&amp;rdquo;) &amp;ndash;&amp;gt; &amp;lsquo;Microsoft\n&amp;rsquo;
2. r&amp;quot;&amp;hellip;&amp;quot;：原始字符串，缺陷是不能在末尾有奇数个 &lt;code>\&lt;/code>，且打印出来末尾的偶数个 &lt;code>\&lt;/code> 会被如实保留
3. 直接写两个 &lt;code>\&lt;/code> 转义：打印出来正常，缺点是写的多&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字符串的检查&lt;/p>
&lt;p>使用==&lt;code>in&lt;/code>==和 ==&lt;code>not in&lt;/code>==关键字&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>字符串的格式化
&lt;ul>
&lt;li>format ()：具体见 &lt;a class="link" href="https://mountainatic.github.io/posts/format/" >format()&lt;/a>&lt;/li>
&lt;li>f-string：Python 3.6 起支持，具体见 &lt;a class="link" href="https://mountainatic.github.io/posts/f-string/" >f-string&lt;/a>&lt;/li>
&lt;li>百分号 %：类似于 C 语言，见 &lt;a class="link" href="https://mountainatic.github.io/posts/%e6%a0%bc%e5%bc%8f%e5%8c%96/" >%格式化&lt;/a>&lt;/li>
&lt;li>string.Template 模块：$占位，见 &lt;a class="link" href="https://mountainatic.github.io/posts/stringtemplate/" >string.Template&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="7-结构">7. 结构
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>&lt;strong>顺序结构：从头顺到尾&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分支结构：&lt;/strong>&lt;/p>
&lt;p>==可以有 &lt;code>if 0 &amp;lt; a &amp;lt; 10&lt;/code> 这种写法==&lt;/p>
&lt;ul>
&lt;li>if&lt;/li>
&lt;li>if-else&lt;/li>
&lt;li>if-elif-else&lt;/li>
&lt;li>match-case（3.10+特性）：
&lt;/li>
&lt;/ul>
&lt;p>==如果只是对应关系没有&lt;strong>动作&lt;/strong>，其实使用 dict 更好==&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>循环结构：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>while()&lt;/li>
&lt;li>for：&lt;code>for var in object:&lt;/code>
建议搭配 &lt;code>range()&lt;/code> 或者 dict/list 使用&lt;/li>
&lt;li>break 和 continue：和 C 一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>异常处理结构：&lt;/strong>&lt;/p>
&lt;p>这个结构就是为了程序在出现错误时候，防止崩溃而建立的错误处理机制，主要是&lt;strong>try-except&lt;/strong>结构&lt;/p>
&lt;ul>
&lt;li>
&lt;p>try-except &lt;strong>捕获单个特定异常&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>try-except &lt;strong>捕获多个不同特定异常&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>try-except-as &lt;strong>捕获所有异常&lt;/strong>&lt;/p>
&lt;p>解释一下，Exception 是大部分错误的父类（也就是大部分错误属于 Exception），error 是用于存储错误的变量&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>可以参考&lt;a class="link" href="https://mountainatic.github.io/posts/%e5%bc%82%e5%b8%b8/" >异常&lt;/a>&lt;/strong>&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="8-运算">8. 运算
&lt;/h2>&lt;h3 id="数学运算">数学运算
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>加&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>减&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>乘&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/&lt;/td>
&lt;td>除&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>%&lt;/td>
&lt;td>取模 mod&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>**&lt;/td>
&lt;td>幂&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>//&lt;/td>
&lt;td>向下取整除法（地板除法）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>不强制指定，int 相除为 int，float 相除为 float&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="比较运算">比较运算
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>==&lt;/td>
&lt;td>是否相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!=&lt;/td>
&lt;td>是否不相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;gt;&lt;/td>
&lt;td>是否左大于右&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;&lt;/td>
&lt;td>是否右大于左&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;gt;=&lt;/td>
&lt;td>是否大于等于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;=&lt;/td>
&lt;td>是否小于等于&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="赋值运算">赋值运算
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>=&lt;/th>
&lt;th>+=&lt;/th>
&lt;th>-=&lt;/th>
&lt;th>*=&lt;/th>
&lt;th>/=&lt;/th>
&lt;th>%=&lt;/th>
&lt;th>**=&lt;/th>
&lt;th>//=&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h3 id="位运算">位运算
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>&amp;amp;&lt;/th>
&lt;th>|&lt;/th>
&lt;th>^&lt;/th>
&lt;th>~&lt;/th>
&lt;th>&amp;laquo;&lt;/th>
&lt;th>&amp;raquo;&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>描述&lt;/td>
&lt;td>按位与&lt;/td>
&lt;td>按位或&lt;/td>
&lt;td>按位异或&lt;/td>
&lt;td>按位取反&lt;/td>
&lt;td>左移&lt;/td>
&lt;td>右移&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="逻辑运算">逻辑运算
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>and&lt;/th>
&lt;th>or&lt;/th>
&lt;th>not&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>描述&lt;/td>
&lt;td>x 为 false，返回 false，否则返回 y&lt;/td>
&lt;td>x 不是 0，返回 x 值，否则返回 y 值&lt;/td>
&lt;td>x 为 true，返回 false；x 为 false，返回 true&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="成员运算">成员运算
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>in&lt;/th>
&lt;th>not in&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>描述&lt;/td>
&lt;td>序列中有 x 就返回 true&lt;/td>
&lt;td>序列里没有 x 就返回 false&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="优先级指数按位翻转一元加减号乘除mod地板除法加减法左右移运算and位运算比较运算符等于运算符赋值运算符">优先级：指数&amp;gt;按位翻转/一元加减号&amp;gt;乘除/mod/地板除法&amp;gt;加减法&amp;gt;左右移运算&amp;gt;and&amp;gt;位运算&amp;gt;比较运算符&amp;gt;等于运算符&amp;gt;赋值运算符
&lt;/h3></description></item><item><title>Seaborn 美化图表库</title><link>https://mountainatic.github.io/posts/seaborn-%E7%BE%8E%E5%8C%96%E5%9B%BE%E8%A1%A8%E5%BA%93/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/seaborn-%E7%BE%8E%E5%8C%96%E5%9B%BE%E8%A1%A8%E5%BA%93/</guid><description>&lt;h2 id="图命令">图命令
&lt;/h2>&lt;h3 id="散点图">散点图
&lt;/h3>&lt;h4 id="视觉属性">视觉属性
&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>视觉效果&lt;/th>
&lt;th>类型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>x, y&lt;/td>
&lt;td>点位置&lt;/td>
&lt;td>数值/类别&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hue&lt;/td>
&lt;td>颜色&lt;/td>
&lt;td>类别/数值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>style&lt;/td>
&lt;td>点形状&lt;/td>
&lt;td>类别&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>size&lt;/td>
&lt;td>点大小&lt;/td>
&lt;td>类别/数值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>palettte&lt;/td>
&lt;td>配色方案（hue 使用）&lt;/td>
&lt;td>字符串（预设）/字典&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sizes&lt;/td>
&lt;td>点范围大小（size 使用）&lt;/td>
&lt;td>元组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>markers&lt;/td>
&lt;td>点形状列表（style 使用）&lt;/td>
&lt;td>列表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>alpha&lt;/td>
&lt;td>透明度（0-1）&lt;/td>
&lt;td>数值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>edgecolor&lt;/td>
&lt;td>点边框颜色&lt;/td>
&lt;td>字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>linewidth&lt;/td>
&lt;td>点边框宽度&lt;/td>
&lt;td>数值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Legend&lt;/td>
&lt;td>图例&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>形状（style 对应的 markers）&lt;/th>
&lt;th>Marker 字符&lt;/th>
&lt;th>效果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>圆形&lt;/td>
&lt;td>&lt;code>&amp;quot;o&amp;quot;&lt;/code>&lt;/td>
&lt;td>🔵&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>方形&lt;/td>
&lt;td>&lt;code>&amp;quot;s&amp;quot;&lt;/code>&lt;/td>
&lt;td>🟦&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>三角形（上）&lt;/td>
&lt;td>&lt;code>&amp;quot;^&amp;quot;&lt;/code>&lt;/td>
&lt;td>🔺&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>三角形（下）&lt;/td>
&lt;td>&lt;code>&amp;quot;v&amp;quot;&lt;/code>&lt;/td>
&lt;td>🔻&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>菱形&lt;/td>
&lt;td>&lt;code>&amp;quot;D&amp;quot;&lt;/code>&lt;/td>
&lt;td>🔷&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>八边形&lt;/td>
&lt;td>&lt;code>&amp;quot;8&amp;quot;&lt;/code>&lt;/td>
&lt;td>🛑&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>星形&lt;/td>
&lt;td>&lt;code>&amp;quot;*&amp;quot;&lt;/code>&lt;/td>
&lt;td>⭐&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>加号&lt;/td>
&lt;td>&lt;code>&amp;quot;+&amp;quot;&lt;/code>&lt;/td>
&lt;td>➕&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x&lt;/td>
&lt;td>&lt;code>&amp;quot;x&amp;quot;&lt;/code>&lt;/td>
&lt;td>❌&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>点&lt;/td>
&lt;td>&lt;code>&amp;quot;.&amp;quot;&lt;/code>&lt;/td>
&lt;td>·（很小）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>像素点&lt;/td>
&lt;td>&lt;code>&amp;quot;,&amp;quot;&lt;/code>&lt;/td>
&lt;td>，（极小）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>配色方案&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Deep&lt;/td>
&lt;td>默认&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Pastel&lt;/td>
&lt;td>柔和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Muted&lt;/td>
&lt;td>低饱和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Bright&lt;/td>
&lt;td>高饱和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Dark&lt;/td>
&lt;td>暗色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Set 1&lt;/td>
&lt;td>离散类颜色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Set 2&lt;/td>
&lt;td>离散类颜色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Set 3&lt;/td>
&lt;td>离散类颜色&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>SFR 主要部件</title><link>https://mountainatic.github.io/posts/sfr-%E4%B8%BB%E8%A6%81%E9%83%A8%E4%BB%B6/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/sfr-%E4%B8%BB%E8%A6%81%E9%83%A8%E4%BB%B6/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>地址&lt;/th>
&lt;th>SFR 名称&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x80&lt;/td>
&lt;td>P0&lt;/td>
&lt;td>端口 0 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x81&lt;/td>
&lt;td>SP&lt;/td>
&lt;td>堆栈指针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x87&lt;/td>
&lt;td>PCON&lt;/td>
&lt;td>电源控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x88&lt;/td>
&lt;td>TCON&lt;/td>
&lt;td>定时器控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x89&lt;/td>
&lt;td>TMOD&lt;/td>
&lt;td>定时器模式寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90&lt;/td>
&lt;td>P1&lt;/td>
&lt;td>端口 1 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xA0&lt;/td>
&lt;td>P2&lt;/td>
&lt;td>端口 2 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xB0&lt;/td>
&lt;td>P3&lt;/td>
&lt;td>端口 3 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xD0&lt;/td>
&lt;td>PSW&lt;/td>
&lt;td>程序状态字寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xE0&lt;/td>
&lt;td>ACC&lt;/td>
&lt;td>累加器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xF0&lt;/td>
&lt;td>B&lt;/td>
&lt;td>B 寄存器&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>全字节访问 &lt;code>P1 = 0xFF;&lt;/code>&lt;/strong>&lt;/li>
&lt;li>**逐位访问 &lt;code>sbit LED = P1^0;&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>STC89C52RC单片机</title><link>https://mountainatic.github.io/posts/stc89c52rc%E5%8D%95%E7%89%87%E6%9C%BA/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/stc89c52rc%E5%8D%95%E7%89%87%E6%9C%BA/</guid><description>&lt;h2 id="参数">参数
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>工作电压&lt;/strong>：5.5~3.5 V&lt;/li>
&lt;li>&lt;strong>Flash 存储器&lt;/strong>：8 K&lt;/li>
&lt;li>&lt;strong>SRAM&lt;/strong>：512 Bytes&lt;/li>
&lt;li>&lt;strong>5 K EEPROM&lt;/strong>、8 扇区 2000 h~2 FFFh&lt;/li>
&lt;li>&lt;strong>三个定时器&lt;/strong>&lt;/li>
&lt;li>&lt;strong>没有 A/D&lt;/strong>&lt;/li>
&lt;li>&lt;strong>10 位 8 路有降低 EMI&lt;/strong>&lt;/li>
&lt;li>&lt;strong>是双倍速&lt;/strong>&lt;/li>
&lt;li>&lt;strong>39 个 I/O 口&lt;/strong>&lt;/li>
&lt;li>&lt;strong>4 个支持掉电唤醒&lt;/strong>&lt;/li>
&lt;li>&lt;strong>外部中断&lt;/strong>：有复位、看门狗、ISP、IAP&lt;/li>
&lt;/ul>
&lt;h2 id="结构简介">结构简介
&lt;/h2>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/images/origin.png"
loading="lazy"
alt="origin.png"
class="responsive-image"
>
&lt;figcaption>origin.png&lt;/figcaption>
&lt;/figure>
&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/images/real.png"
loading="lazy"
alt="real.png"
class="responsive-image"
>
&lt;figcaption>real.png&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="cpu">CPU
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>位数&lt;/strong>：8 位&lt;/li>
&lt;li>&lt;strong>峰值速度&lt;/strong>：12 时钟周期/机器周期&lt;/li>
&lt;li>&lt;strong>组成&lt;/strong>：运算器，控制器，支持位处理（用于控制）&lt;/li>
&lt;/ul>
&lt;h3 id="存储器">存储器
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Flash ROM&lt;/strong>：8 KB，用于存放用户代码和常量，支持在线编程（ISP/IAP）&lt;/li>
&lt;li>&lt;strong>Data Flash（可用作 EEPROM）&lt;/strong>：9 KB，用于保存不是特别频繁更新的数据，如配置参数、校准值等，擦写寿命 10 w+，有多个扇区，建议一次修改的放同一个&lt;/li>
&lt;li>&lt;strong>RAM&lt;/strong>：256 Bytes，其中低 128 Bytes 为用户可访问，另外 128 Bytes 为高 128 Bytes
&lt;ul>
&lt;li>&lt;strong>高 128 Bytes RAM&lt;/strong> 与特殊功能寄存器共用相同地址范围，但物理上独立，高 RAM 只能间接寻址，SFRs 可以直接寻址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="外部存储器接口">外部存储器接口
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>外部程序存储器&lt;/strong>：可通过 EA 引脚选择是否启用外部程序存储器，启用外部程序存储器后，复位后会从外部存储器的第一个地址开始取指令执行。&lt;/li>
&lt;li>&lt;strong>外部数据存储器&lt;/strong>：提供额外的数据存储空间，最大可达 64 KB。&lt;/li>
&lt;/ul>
&lt;h3 id="输入输出端口-io-ports-p-0---p-3-端口">输入输出端口 (I/O Ports) P 0 - P 3 端口
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>数量&lt;/strong>：4 个 8 位并行 I/O 端口（P 0、P 1、P 2、P 3）&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：每个端口可以独立设置为输入或输出，并且具有多种复用功能（如 P 3 端口的引脚还可用作串行通信、中断输入等）&lt;/li>
&lt;li>&lt;strong>特性&lt;/strong>：部分引脚具备第二功能，例如定时器、串行通信、中断等&lt;/li>
&lt;/ul>
&lt;h3 id="定时计数器">定时/计数器
&lt;/h3>&lt;h4 id="定时器计数器-t-0-和-t-1">定时器/计数器 T 0 和 T 1
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>类型&lt;/strong>：16 位定时器/计数器&lt;/li>
&lt;li>&lt;strong>模式&lt;/strong>：支持多种工作模式，包括定时模式和计数模式&lt;/li>
&lt;li>&lt;strong>用途&lt;/strong>：用于测量时间间隔或计算事件次数&lt;/li>
&lt;/ul>
&lt;h4 id="定时器-t-2">定时器 T 2
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>类型&lt;/strong>：额外的 16 位定时器/计数器&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>：可以作为捕捉模式或波特率发生器使用&lt;/li>
&lt;/ul>
&lt;h3 id="中断系统">中断系统
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>中断源&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>外部中断 INT 0 和 INT 1&lt;/strong>：分别由 P 3.2 和 P 3.3 引脚触发&lt;/li>
&lt;li>&lt;strong>定时器中断&lt;/strong>：来自 T 0、T 1 和 T 2 的溢出中断&lt;/li>
&lt;li>&lt;strong>串行口中断&lt;/strong>：用于接收和发送数据完成时触发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优先级&lt;/strong>：支持两级中断优先级，可以灵活配置中断响应顺序&lt;/li>
&lt;/ul>
&lt;h3 id="串行通信接口-uart通用异步收发传输器">串行通信接口 UART（通用异步收发传输器）
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：支持全双工串行通信，适用于与计算机或其他设备交换数据&lt;/li>
&lt;li>&lt;strong>波特率&lt;/strong>：可通过定时器设置不同的波特率&lt;/li>
&lt;/ul>
&lt;h3 id="电源管理和复位电路">电源管理和复位电路
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>电源管理&lt;/strong>：支持低功耗模式，如空闲模式和掉电模式，以节省能源&lt;/li>
&lt;li>&lt;strong>复位电路&lt;/strong>：包含上电复位和手动复位功能，确保单片机在启动或异常情况下恢复正常操作&lt;/li>
&lt;/ul>
&lt;h3 id="其他特性">其他特性
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>看门狗定时器 (WDT)&lt;/strong>：防止程序跑飞，自动重启单片机&lt;/li>
&lt;li>&lt;strong>低压检测 (LVD)&lt;/strong>：监控电源电压，当电压低于设定阈值时产生中断或复位&lt;/li>
&lt;li>&lt;strong>In-Application Programming (IAP)&lt;/strong>：允许应用程序对内部 Flash 进行读写操作，实现动态更新固件的功能&lt;/li>
&lt;/ul>
&lt;h2 id="引脚介绍">引脚介绍
&lt;/h2>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/posts/structurepng/"
loading="lazy"
alt="500"
class="responsive-image"
>
&lt;figcaption>500&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="电源引脚">电源引脚
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Vcc&lt;/strong>：电源正极&lt;/li>
&lt;li>&lt;strong>Vss / Gnd&lt;/strong>：负极，接地&lt;/li>
&lt;/ul>
&lt;h3 id="时钟引脚">时钟引脚
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>XTAL 1&lt;/strong>：
&lt;ul>
&lt;li>a. 内部时钟电路反相放大器输入端，接外部晶振引脚之一&lt;/li>
&lt;li>b. 使用外部时钟源时候，该引脚为输入源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>XTAL 2&lt;/strong>：
&lt;ul>
&lt;li>a. 内部时钟电路反相放大器输出端，接外部晶振引脚之一&lt;/li>
&lt;li>b. 使用外部时钟源时候，该引脚可直接浮空&lt;/li>
&lt;li>带 &amp;ldquo;RC&amp;rdquo; 后缀一般自带==内部 RC 时钟==，可以通过配置 SFRs 启用
&lt;ul>
&lt;li>可以通过==外接晶振==+==反相放大器==实现 “半内部时钟源”，具体就是 XTAL 1 进 XTAL 2 出（在这套系统彻底启动前，即所谓的 “振荡器启动时间” ，RC 时钟会代替产生信号）&lt;/li>
&lt;li>（基本都会有 RC 时钟，没有的可能会用 delay ()，或者看门狗，等待，上电复位等手段解决）&lt;/li>
&lt;li>也可以直接由 XTAL 1 接入==外部时钟源==&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="控制引脚">控制引脚
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>RST&lt;/strong>： 在引脚上施加持续时间大于两个机器周期（对于该单片机准确来说是 24 个时钟+10 us）的高电平来复位（通常是通过连接到 Vcc） 正常工作时电平应该&amp;lt;=0.5 V&lt;/li>
&lt;li>&lt;em>&lt;em>EA&lt;/em>/Vpp（Enable Address/Voltage Pulse of Programming）&lt;/em>*
&lt;ul>
&lt;li>
&lt;p>a. 外部程序存储器访问允许控制端（实际上控制的是内部存储器）&lt;/p>
&lt;ul>
&lt;li>&lt;em>&lt;em>EA&lt;/em> = 0（低电平 —— 接地，就连接到 GND）&lt;/em>*，仅读取外部存储器内容（0000 H~FFFFH），片内 8 K 的程序存储器被禁用&lt;/li>
&lt;li>&lt;em>&lt;em>EA&lt;/em> = 1（高电平 —— 一般是连接到 Vcc）&lt;/em>*，==优先读取片内程序 ==在 PC 值（程序计数器中存放的数值，就是下一条指令的地址）不超出片上 8 KB Flash（即 1 FFFH）时，单片机只读取该 Flash 内容==超出去自动转向片外存储器==&lt;/li>
&lt;li>&lt;strong>b. Vpp&lt;/strong>：对片内 Flash 编程，接编程电压&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>注意：版本不一样&lt;/p>
&lt;ul>
&lt;li>HD 版本和 90 C 版本内部都集成了 MAX 810 复位电路，但时钟频率为 6 MHz 时候该复位电路可靠，12 MHz 勉强可用&lt;/li>
&lt;li>HD 版有 PSEN、ALE 和 EA 管脚没有 P 4.4/. 5/. 6 口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>string.Template</title><link>https://mountainatic.github.io/posts/stringtemplate/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/stringtemplate/</guid><description/></item><item><title>画板子</title><link>https://mountainatic.github.io/posts/%E7%94%BB%E6%9D%BF%E5%AD%90/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E7%94%BB%E6%9D%BF%E5%AD%90/</guid><description>&lt;h3 id="三极管">三极管
&lt;/h3>&lt;p>&lt;strong>主要有基极 Base、集电极 Collector、发射极 Emitter组成&lt;/strong>
![Pasted image 20250205112937.jpg](/images/Pasted image 20250205112937.jpg)&lt;/p>
&lt;h4 id="npn-型">NPN 型
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>简称 N 型，基极电压必须高于发射极电压才能导通，电流由集电极 → 发射极&lt;/strong>&lt;/li>
&lt;li>&lt;strong>常用于==低侧驱动==，适合 LED、继电器等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="pnp-型">PNP 型
&lt;/h4>&lt;ul>
&lt;li>**简称 P 型，基极电压必须低于发射极电压，一般由发射极 → 集电极&lt;/li>
&lt;li>&lt;strong>常用于==高侧驱动==，适合电机等大功率设备&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>有三种工作模式, 截止区、放大区、饱和区&lt;/strong>&lt;/p></description></item><item><title>简述</title><link>https://mountainatic.github.io/posts/%E7%AE%80%E8%BF%B0/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E7%AE%80%E8%BF%B0/</guid><description>&lt;h2 id="建议路径">建议路径：
&lt;/h2>&lt;ol>
&lt;li>学 C 语言（学校肯定教，知道基础的就行，起码三类结构啥的得清楚）&lt;/li>
&lt;li>首先知道冯 · 依诺曼机和图灵机，有个大概印象&lt;/li>
&lt;li>看&lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b/" >因你而在的故事&lt;/a>这个，对着原理图看每个部分的介绍&lt;/li>
&lt;li>看 &lt;a class="link" href="https://mountainatic.github.io/posts/c51%e7%ae%80%e8%bf%b0/" >C51简述&lt;/a>，知道 RAM 的精妙用处，会（起码知道原理，查表能查出来）定义变量、会通过 SFR 控制引脚（还不用知道具体有哪些）&lt;/li>
&lt;li>看引脚介绍&lt;/li>
&lt;/ol></description></item><item><title>设计方案</title><link>https://mountainatic.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</guid><description>&lt;h3 id="第一步需求分析">第一步：需求分析
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>基础功能&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用步进电机模拟洗衣机桶的旋转。&lt;/li>
&lt;li>使用数码管显示剩余时间或当前状态。&lt;/li>
&lt;li>使用独立按键控制洗衣机的启动/停止。&lt;/li>
&lt;li>使用 LED 灯显示当前的工作阶段（如进水、浸泡、洗衣、脱水、结束）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>扩展功能&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>实现紧急停止功能，当按下特定按键时立即停止所有操作。&lt;/li>
&lt;li>如果有光敏电阻，检测光线强度以决定是否允许洗衣机工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="第二步硬件选择与连接">第二步：硬件选择与连接
&lt;/h3>&lt;h4 id="硬件组件选择">硬件组件选择
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>步进电机&lt;/strong>：选择适合的步进电机（如 28 BYJ-48），并准备相应的驱动芯片（如 ULN 2003）。&lt;/li>
&lt;li>&lt;strong>数码管&lt;/strong>：选择 7 段数码管用于显示时间或状态信息。&lt;/li>
&lt;li>&lt;strong>独立按键&lt;/strong>：准备两个独立按键，一个用于启动洗衣机，另一个用于紧急停止。&lt;/li>
&lt;li>&lt;strong>LED 灯&lt;/strong>：准备四个 LED 灯来指示不同的工作阶段。&lt;/li>
&lt;li>&lt;strong>蜂鸣器&lt;/strong>（可选）：用于提醒用户洗衣机的状态变化。&lt;/li>
&lt;li>&lt;strong>光敏电阻&lt;/strong>（可选）：用于检测环境光线强度。&lt;/li>
&lt;/ul>
&lt;h4 id="硬件连接">硬件连接
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>步进电机&lt;/strong>：将步进电机的引脚连接到驱动芯片的输出端，再将驱动芯片的输入端连接到 51 单片机的 GPIO 口。&lt;/li>
&lt;li>&lt;strong>数码管&lt;/strong>：如果数码管较多，可以通过移位寄存器（如 74 HC 595）减少单片机的 GPIO 占用。将数码管的段选线连接到移位寄存器的输出端，控制线连接到单片机。&lt;/li>
&lt;li>&lt;strong>独立按键&lt;/strong>：按键的一端接地，另一端通过上拉电阻连接到 51 单片机的 GPIO 口。&lt;/li>
&lt;li>&lt;strong>LED 灯&lt;/strong>：每个 LED 灯连接到单片机的一个 GPIO 口，并串联限流电阻。&lt;/li>
&lt;li>&lt;strong>蜂鸣器&lt;/strong>：蜂鸣器连接到单片机的一个 GPIO 口，并根据需要添加限流电阻或驱动电路。&lt;/li>
&lt;li>&lt;strong>光敏电阻&lt;/strong>：光敏电阻连接到单片机的 ADC 输入端，以便读取光照强度。&lt;/li>
&lt;/ul>
&lt;h3 id="第三步软件编程">第三步：软件编程
&lt;/h3>&lt;h4 id="初始化">初始化
&lt;/h4>&lt;ul>
&lt;li>配置定时器用作延时函数的基础。&lt;/li>
&lt;li>设置 I/O 端口的方向，初始化数码管和 LED 灯的状态。&lt;/li>
&lt;/ul>
&lt;h4 id="主程序逻辑">主程序逻辑
&lt;/h4>&lt;ul>
&lt;li>创建主循环，在其中等待按键事件。&lt;/li>
&lt;li>当检测到启动按键被按下时，进入工作流程。&lt;/li>
&lt;li>按照预设的时间间隔更新数码管上的显示内容。&lt;/li>
&lt;li>根据当前状态控制 LED 灯亮灭。&lt;/li>
&lt;li>控制步进电机按照预定模式旋转（正转、反转、停止）。&lt;/li>
&lt;/ul>
&lt;h4 id="中断服务程序isr">中断服务程序（ISR）
&lt;/h4>&lt;ul>
&lt;li>如果使用定时器中断，则在 ISR 中处理计时任务，例如更新时间、控制电机旋转等。&lt;/li>
&lt;li>如果使用外部中断来捕捉按键事件，可以在 ISR 中设置标志位或者直接响应按键动作。&lt;/li>
&lt;/ul>
&lt;h4 id="键盘扫描">键盘扫描
&lt;/h4>&lt;ul>
&lt;li>编写键盘扫描函数，定期检查按键状态，以触发相应的动作。&lt;/li>
&lt;/ul>
&lt;h4 id="步进电机控制">步进电机控制
&lt;/h4>&lt;ul>
&lt;li>编写函数来控制步进电机的转动方向和速度，可以通过改变脉冲序列实现正转、反转及停止。&lt;/li>
&lt;/ul>
&lt;h4 id="数码管显示">数码管显示
&lt;/h4>&lt;ul>
&lt;li>编写函数负责将数字转换为 7 段数码管所需的段码，并通过适当的接口发送给数码管。&lt;/li>
&lt;li>根据文献，P2.2/3/4 控制译码器，P0 输出&lt;/li>
&lt;/ul>
&lt;h4 id="光线检测如果有光敏电阻">光线检测（如果有光敏电阻）
&lt;/h4>&lt;ul>
&lt;li>编写函数读取光敏电阻的模拟值，并据此判断是否允许洗衣机工作。&lt;/li>
&lt;/ul>
&lt;h4 id="延时函数">延时函数
&lt;/h4>&lt;p>定时器实现：&lt;/p>
&lt;p>双循环实现：&lt;/p>
&lt;h4 id="独立按键">独立按键
&lt;/h4>&lt;ul>
&lt;li>按下按键1后按工作流程开始工作&lt;/li>
&lt;li>在洗衣机工作过程中的任意时间按下按键2，立即结束流程停转&lt;/li>
&lt;li>根据文献，P3.0~3 分别有对应：
1 &amp;ndash;&amp;gt; 3.1
2 &amp;ndash;&amp;gt; 3.0
3 &amp;ndash;&amp;gt; 3.2
4 &amp;ndash;&amp;gt; 3.3&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Caution]+ 目前已经使用的口
LSA/B/C &amp;mdash;&amp;gt; P2^2&lt;del>4
SMG_A_DP_PORT &amp;mdash;&amp;gt; P0
KEY 1-4 &amp;mdash;&amp;gt; P3.0&lt;/del>3&lt;/p>
&lt;/blockquote></description></item><item><title>数学命令</title><link>https://mountainatic.github.io/posts/%E6%95%B0%E5%AD%A6%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E6%95%B0%E5%AD%A6%E5%91%BD%E4%BB%A4/</guid><description/></item><item><title>未命名</title><link>https://mountainatic.github.io/posts/%E6%9C%AA%E5%91%BD%E5%90%8D/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E6%9C%AA%E5%91%BD%E5%90%8D/</guid><description/></item><item><title>异常</title><link>https://mountainatic.github.io/posts/%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E5%BC%82%E5%B8%B8/</guid><description>&lt;p>&lt;strong>异常是在程序收到错误时，防止崩溃而做出的一种&amp;quot;应急预案&amp;quot;，会给出程序错误的原因和节点&lt;/strong>&lt;/p>
&lt;p>基本异常主要包括下面的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>你可以&lt;strong>自定义异常&lt;/strong>：&lt;/p>
&lt;p>输出为 &lt;code>捕获到异常： MyError - 写展示的内容&lt;/code>&lt;/p>
&lt;p>&lt;code>class&lt;/code> 表示了 MyError 继承自 Exception
&lt;code>raise&lt;/code> 表示手动抛出异常
&lt;code>as&lt;/code> 捕获了自定义异常&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以在异常里&lt;strong>传参&lt;/strong>：&lt;/p>
&lt;p>待完善&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以在异常里嵌套 (异常链，便于跟踪)&lt;/p>
&lt;p>待完善&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以同时创建多个自定义异常&lt;/p>
&lt;p>待完善&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以结合 try-except 进行异常处理&lt;/p>
&lt;p>待完善&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>因你而在的故事</title><link>https://mountainatic.github.io/posts/%E5%9B%A0%E4%BD%A0%E8%80%8C%E5%9C%A8%E7%9A%84%E6%95%85%E4%BA%8B/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E5%9B%A0%E4%BD%A0%E8%80%8C%E5%9C%A8%E7%9A%84%E6%95%85%E4%BA%8B/</guid><description>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/images/real.png"
loading="lazy"
alt="real.png"
class="responsive-image"
>
&lt;figcaption>real.png&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h1 id="看图看图看图理解">&lt;strong>==看图！看图！看图理解！==&lt;/strong>
&lt;/h1>&lt;p>==&lt;strong>不需要深究物理原理，知道每个部分有啥功能就行，原理都是从功能角度设计的！！！&lt;/strong>==&lt;/p>
&lt;h2 id="存储器部分">存储器部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>RAM 地址寄存器&lt;/strong>：存储了 RAM 中数据的地址（包括 RAM 和 AUX-RAM），CPU 在需要读写 RAM 时候告诉 CPU 数据的存取位置&lt;/li>
&lt;li>&lt;strong>RAM&lt;/strong>：更靠近 CPU，存放局部变量、寄存器的值等&lt;/li>
&lt;li>*&lt;em>AUX-RAM&lt;/em>：“物理上片内，逻辑上外部”，扩展内存，是辅助 RAM 存放更多数据的&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol start="4">
&lt;li>&lt;strong>程序存储器（Flash）&lt;/strong>：永久==保存程序、固件等大块数据==，断电不丢失，MCU 启动后从这里运行&lt;/li>
&lt;li>&lt;strong>EEPROM&lt;/strong>：用于保存需要长期存储的值，断电不丢失，主要==储存经常需要修改的少量数据==，如==配置参数、用户设置、校准数据等==&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>[!notes] 区别&lt;/p>
&lt;ul>
&lt;li>Flash 一般成块（Block）或者页（Page）写入，速度快，写入寿命比下面的短，但容量大&lt;/li>
&lt;li>EEPROM 支持按字节写入，适合修改少量数据，速度慢，写入寿命比上面的长，但容量小&lt;/li>
&lt;li>后记：实际上目前国产STC宏晶系列不管是Flash还是EEPROM都全用上Flash芯片了，也不是特别分这个，实际不是MCU仙人，平常做项目根本没有要写进这里面的，相当于是断电还要保存的数据，要断电重启的项目应该也开始用stm32之类的了，51还是太简单了（逃）&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="运算控制部分">运算控制部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>ACC（累加器）&lt;/strong>
&lt;ul>
&lt;li>本质是一个寄存器，用来==存储==运算过程中的数据和最终结果&lt;/li>
&lt;li>叫累加器是==因为经常在累加过程中用到==，当然==加减法逻辑运算都支持==&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**临时寄存器（TMP1 &amp;amp; TMP2）
&lt;ul>
&lt;li>用于保存中间数据&lt;/li>
&lt;li>两个可能是因为方便复杂运算（第一步结果存到 1，第二步存到 2）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ALU（算术逻辑单元）&lt;/strong>
&lt;ul>
&lt;li>==执行==所有算术和逻辑运算&lt;/li>
&lt;li>从累加器和临时寄存器去除操作数，计算，存回累加器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PSW（程序状态字寄存器）&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：
主要用来==记录计算状态==，记录的是标志位，如：
&lt;ul>
&lt;li>&lt;strong>进位标志（CY）：&lt;/strong> 如果运算结果超过了寄存器的存储能力（比如 8 位运算结果超过 255），就会设置进位标志。&lt;/li>
&lt;li>&lt;strong>零标志（Z）：&lt;/strong> 如果运算结果是 0，这个位会被置位。&lt;/li>
&lt;li>&lt;strong>溢出标志（OV）：&lt;/strong> 如果运算结果超出了允许的范围（比如符号位有问题），会设置这个标志。
&lt;em>&lt;strong>记录的是重要事件，相当于备忘录，“师傅，该进一了”&lt;/strong>&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol start="5">
&lt;li>&lt;strong>双数据指针&lt;/strong>
&lt;ul>
&lt;li>允许MCU同时指向两个不同的内存地址，可以快速切换数据（&lt;del>左脚踩右脚&lt;/del>）&lt;/li>
&lt;li>比如：一个读数据，一个写数据；左右交替处理数组之类的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>堆栈指针&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>就像一个==书签==，标识/记录堆栈的顶部位置&lt;/strong>&lt;/li>
&lt;li>堆栈是一个特殊的内存区域，用来管理程序调用，比如函数之间的跳转和返回&lt;/li>
&lt;li>该指针可以在：
&lt;ul>
&lt;li>调用一个函数时，保存当前的位置，以便函数执行完毕后可以正确返回&lt;/li>
&lt;li>嵌套函数调用中，“找对正确的路”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="定时通信部分">定时通信部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>定时器 0/1 与定时器 2&lt;/strong>
&lt;ul>
&lt;li>精确管理时间/计数，如：时间控制、时间计数&lt;/li>
&lt;li>&lt;strong>大概的模式&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>定时模式&lt;/strong>：根据时钟源计时，达到设定时间后触发一个中断&lt;/li>
&lt;li>&lt;strong>计数模式&lt;/strong>：根据外部输入信号脉冲个数计数，达到几几次后触发中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多个定时器便于同时管理多个任务&lt;/li>
&lt;li>0/1 和 2 分开==可能是==因为 0 与 1 设计差不多，而与 2 不一样&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>串口（UART）&lt;/strong>
&lt;ul>
&lt;li>MCU 与其他设备通信的桥梁，使用&lt;strong>串行通信协议&lt;/strong>，一位一位地发送信息&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>
&lt;ul>
&lt;li>单通道：MCU 一次只能与一个设备通信（用协议可以在外拓展）&lt;/li>
&lt;li>速度调节：支持不同波特率（传输速度）&lt;/li>
&lt;li>双向通信：允许双向发送消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>看门狗定时器（WDT）&lt;/strong>
&lt;ul>
&lt;li>安全机制，程序正常运行时，MCU 会定期重置 WDT；==当程序卡住/死循环==，看门狗没有被重置，WDT 会触发==复位==，重新启动 MCU&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="程序控制--存储器交互部分">程序控制 &amp;amp; 存储器交互部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>PC（程序计数器）&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：是一个寄存器，用来储存当前正在执行的指令的地址，引导执行下一条指令&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>：
&lt;ul>
&lt;li>每执行一条指令，PC 的值自动增加，指向下一个指令的地址&lt;/li>
&lt;li>遇到跳转指令时候（&lt;code>JUMP&lt;/code> 或者 &lt;code>CALL&lt;/code> 等），PC 会被修改为跳转目标的地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>地址生成器&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用：&lt;/strong> 地址生成器负责生成 MCU 内部各模块所需的存储器地址。
&lt;ul>
&lt;li>包括程序存储器（Flash）、数据存储器（RAM）和特殊功能寄存器（SFR）的地址。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>用途：&lt;/strong>
&lt;ul>
&lt;li>当处理器需要从存储器读取数据或写入数据时，地址生成器会根据指令提供对应的地址。&lt;/li>
&lt;li>它与程序计数器配合，确保指令和数据在正确的时间被正确访问。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>[!Question] 为什么 PC 和地址生成器都要的是“地址”，而感觉好像这俩地址不一样？
因为==PC==中的地址是&lt;strong>逻辑地址&lt;/strong>，是&lt;strong>抽象地址&lt;/strong>
而真正的&lt;strong>物理地址&lt;/strong>是由&lt;strong>地址生成器&lt;/strong>处理的，它将 PC 的逻辑地址查找/计算出对应物理地址
因此实际的时序是：当处理器准备取下一条指令时候，PC 的值已经更新，递给地址生成器，其根据这个值生成对应 Flash 中地址&lt;/p>
&lt;/blockquote>
&lt;ol start="3">
&lt;li>&lt;strong>Flash（程序存储器）&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：一般用来存储程序，可反复擦写，运行时只读，编程时可以通过 ISP/IAP 擦写&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ISP/IAP（在线编程与应用编程）&lt;/strong>
&lt;ul>
&lt;li>ISP：通过特定接口（USB、串口）修改 Flash 内容&lt;/li>
&lt;li>IAP：程序运行时，更新 Flash 中的部分内容（比如 OTA）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol start="5">
&lt;li>&lt;strong>存储器和控制模块的协作&lt;/strong>
&lt;ul>
&lt;li>PC 指向当前指令的地址&lt;/li>
&lt;li>地址生成器根据 PC 提供的地址，从程序存储器中读取指令（实际上是 Flash 读取指令，生成器只是生成了地址）&lt;/li>
&lt;li>指令被送到控制单元，控制单元解析指令并产生对应的操作&lt;/li>
&lt;li>如果需要访问数据存储器（RAM）或特殊寄存器，地址生成器会生成相应的地址&lt;/li>
&lt;li>执行完成后，PC 自动指向下一条指令，进入下一个循环&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="io-接口">I/O 接口
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>锁存器(Port 0,1,2,3,4 锁存器)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>保存和稳定数据&lt;/strong>。用于保存 I/O 口的数据状态，比如，当 CPU 将一个数据写入到某个 I/O 端口时，锁存器负责将数据固定，直到被下一个数据覆盖&lt;/li>
&lt;li>&lt;strong>双向的&lt;/strong>。可以把==输出==的信号稳定，也可以把==输入==的信号去抖/同步/&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>工作方式&lt;/strong>：
&lt;ul>
&lt;li>CPU 输出数据时，数据会经过总线，先进入锁存器，锁存器会将其稳定后再传递给 I/O 驱动器&lt;/li>
&lt;li>锁存器会&lt;strong>暂时存储&lt;/strong>从总线上传输的数据，并将其锁定（Latch）。直到信号完全稳定后，才会将数据传递给后续模块（如 I/O 驱动器）。&lt;/li>
&lt;li>锁存器通过时钟信号或者控制信号同步数据切换，确保输出的信号是一个完整、确定的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>&lt;strong>提供了 MCU 内部与外部的缓冲区和隔离层&lt;/strong>&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>驱动器&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>
&lt;ul>
&lt;li>负责将锁存器输出的数据==传出==物理引脚&lt;/li>
&lt;li>==接收==外部信号，通过驱动器传递到 CPU
&lt;em>通常有电平转换电路，用于适应不同的外部设备电压要求&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>I/O 引脚（P0, P1, P2, P3, P4）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>
&lt;ul>
&lt;li>不同的端口支持不同的功能，例如某些引脚可以配置为 UART、SPI、I2C 或 ADC 通道。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>数据流&lt;/strong>
&lt;ul>
&lt;li>当 CPU 要输出数据时：数据 → 锁存器 → 驱动器 → I/O 引脚。&lt;/li>
&lt;li>当 CPU 要读取数据时：外部信号 → I/O 引脚 → 驱动器 → CPU。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="控制单元">控制单元
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：协调模块运作，解析指令，产生控制信号&lt;/li>
&lt;li>&lt;strong>组成&lt;/strong>：
&lt;ol>
&lt;li>&lt;strong>时钟电路&lt;/strong>：XTAL1 与 XTAL2 是外部晶振接口，提供一个固定频率的时钟信号&lt;/li>
&lt;li>&lt;strong>复位引脚&lt;/strong>：重新加载程序计数器、清空寄存器，确保系统从头开始运行&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>作用&lt;/strong>：
&lt;ol>
&lt;li>从存储器中取出指令&lt;/li>
&lt;li>解析指令内容&lt;/li>
&lt;li>生成操作信号&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="总线">总线
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>传递数据、地址和控制信号的通道&lt;/strong>&lt;/li>
&lt;li>&lt;strong>分类：&lt;/strong>
&lt;ol>
&lt;li>数据总线&lt;/li>
&lt;li>地址总线&lt;/li>
&lt;li>控制总线&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>总线是一种共享资源。为了避免多个模块同时使用总线导致冲突，MCU 内部会有一个&lt;strong>总线仲裁器&lt;/strong>（Bus Arbiter）来管理总线的访问权。&lt;/li>
&lt;/ul></description></item><item><title>极简 Callout 测试</title><link>https://mountainatic.github.io/posts/simple-callout-test/</link><pubDate>Mon, 11 Aug 2025 11:55:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/simple-callout-test/</guid><description>&lt;h1 id="极简-callout-测试">极简 Callout 测试
&lt;/h1>&lt;script>
console.log('页面脚本开始执行');
console.log('检查是否有 obsidian-syntax-new.js:', document.querySelector('script[src*="obsidian-syntax-new.js"]'));
console.log('检查是否有 style.css:', document.querySelector('link[href*="style"]'));
// 等待页面加载完成后检查
setTimeout(() => {
console.log('3秒后检查 DOM:');
const blockquotes = document.querySelectorAll('blockquote');
console.log('找到的 blockquote 数量:', blockquotes.length);
const callouts = document.querySelectorAll('.obsidian-callout');
console.log('找到的 .obsidian-callout 数量:', callouts.length);
if (blockquotes.length > 0 &amp;&amp; callouts.length === 0) {
console.log('❌ Callout 转换失败 - blockquote 存在但没有被转换');
} else if (callouts.length > 0) {
console.log('✅ Callout 转换成功');
}
}, 3000);
&lt;/script>
&lt;p>测试单个 callout：&lt;/p>
&lt;blockquote>
&lt;p>[!NOTE]
这是一个测试 callout。&lt;/p>
&lt;/blockquote>
&lt;p>结束。&lt;/p></description></item><item><title>Callout 样式测试</title><link>https://mountainatic.github.io/posts/callout-style-test/</link><pubDate>Mon, 11 Aug 2025 11:45:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/callout-style-test/</guid><description>&lt;h1 id="callout-样式测试">Callout 样式测试
&lt;/h1>&lt;style>
.obsidian-callout {
margin: 1em 0;
border-radius: 6px;
border-left: 4px solid #3b82f6;
background: rgba(59, 130, 246, 0.05);
overflow: hidden;
}
.obsidian-callout-title {
display: flex;
align-items: center;
padding: 12px 16px;
background: rgba(59, 130, 246, 0.1);
font-weight: 600;
color: #3b82f6;
gap: 8px;
}
.obsidian-callout-content {
padding: 12px 16px;
}
.obsidian-callout-note {
border-left-color: #3b82f6;
}
.obsidian-callout-tip {
border-left-color: #10b981;
}
.obsidian-callout-warning {
border-left-color: #f59e0b;
}
&lt;/style>
&lt;p>测试基本的 callout：&lt;/p>
&lt;blockquote>
&lt;p>[!NOTE]
这是一个基本的 NOTE callout。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TIP]
这是一个 TIP callout。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!WARNING]
这是一个 WARNING callout。&lt;/p>
&lt;/blockquote>
&lt;p>结束测试。&lt;/p></description></item><item><title>Callout 调试测试</title><link>https://mountainatic.github.io/posts/callout-debug/</link><pubDate>Mon, 11 Aug 2025 11:40:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/callout-debug/</guid><description>&lt;h1 id="callout-调试测试">Callout 调试测试
&lt;/h1>&lt;p>测试基本的 callout：&lt;/p>
&lt;blockquote>
&lt;p>[!NOTE]
这是一个基本的 NOTE callout。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TIP]
这是一个 TIP callout。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!WARNING]
这是一个 WARNING callout。&lt;/p>
&lt;/blockquote>
&lt;p>结束测试。&lt;/p></description></item><item><title>Obsidian Callout 完整测试 - 修复版</title><link>https://mountainatic.github.io/posts/callout-fold-test/</link><pubDate>Mon, 11 Aug 2025 11:30:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/callout-fold-test/</guid><description>&lt;h1 id="obsidian-callout-完整测试">Obsidian Callout 完整测试
&lt;/h1>&lt;h2 id="基本语法测试">基本语法测试
&lt;/h2>&lt;blockquote>
&lt;p>[!NOTE]
基本的 note callout，无自定义标题。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!NOTE] 自定义标题
带有自定义标题的 note callout。&lt;/p>
&lt;/blockquote>
&lt;h2 id="折叠语法测试仅识别不实现折叠">折叠语法测试（仅识别，不实现折叠）
&lt;/h2>&lt;blockquote>
&lt;p>[!NOTE+]
默认展开的 note callout。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!WARNING-]
默认折叠的 warning callout。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TIP+] 展开提示
带自定义标题的展开 tip callout。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!DANGER-] 折叠危险
带自定义标题的折叠 danger callout。&lt;/p>
&lt;/blockquote>
&lt;h2 id="所有类型测试">所有类型测试
&lt;/h2>&lt;blockquote>
&lt;p>[!ABSTRACT]
Abstract callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!SUMMARY] 摘要标题
Summary 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TLDR] 太长不看
TLDR 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!INFO]
Info callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TODO]
Todo callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TIP]
Tip callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!HINT] 提示
Hint 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!IMPORTANT] 重要
Important 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!SUCCESS]
Success callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!CHECK] 检查
Check 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!DONE] 完成
Done 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!QUESTION]
Question callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!HELP] 帮助
Help 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!FAQ] 常见问题
FAQ 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!WARNING]
Warning callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!CAUTION] 小心
Caution 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!ATTENTION] 注意
Attention 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!FAILURE]
Failure callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!FAIL] 失败
Fail 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!MISSING] 缺失
Missing 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!DANGER]
Danger callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!ERROR] 错误
Error 别名测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!BUG]
Bug callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!EXAMPLE]
Example callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!QUOTE]
Quote callout 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!CITE] 引用来源
Cite 别名测试。&lt;/p>
&lt;/blockquote>
&lt;h2 id="多行内容测试">多行内容测试
&lt;/h2>&lt;blockquote>
&lt;p>[!NOTE] 多行测试
这是第一行内容。&lt;/p>
&lt;p>这是第二行内容，中间有空行。&lt;/p>
&lt;ul>
&lt;li>列表项 1&lt;/li>
&lt;li>列表项 2&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>粗体文本&lt;/strong> 和 &lt;em>斜体文本&lt;/em>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="大小写测试">大小写测试
&lt;/h2>&lt;blockquote>
&lt;p>[!note] 小写
小写 note 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!WARNING] 大写
大写 WARNING 测试。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TiP] 混合大小写
混合大小写 TiP 测试。&lt;/p>
&lt;/blockquote></description></item><item><title>代码测试</title><link>https://mountainatic.github.io/memos/2025-08-10-code-test/</link><pubDate>Sun, 10 Aug 2025 22:35:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-code-test/</guid><description>&lt;p>测试一下代码块字体是否正确：&lt;/p>
&lt;p>使用 &lt;code>console.log('Hello World')&lt;/code> 来输出信息。&lt;/p>
&lt;p>这应该显示为等宽字体：&lt;code>var x = 42;&lt;/code>&lt;/p></description></item><item><title>技术发现</title><link>https://mountainatic.github.io/memos/2025-08-10-tech-discovery/</link><pubDate>Sun, 10 Aug 2025 19:30:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-tech-discovery/</guid><description>&lt;p>发现了一个很有趣的CSS特性：&lt;code>column-count&lt;/code> 可以很轻松地实现瀑布流布局！&lt;/p>
&lt;p>配合 &lt;code>break-inside: avoid&lt;/code> 可以防止内容被断开，这样就能创造出类似Pinterest的效果。&lt;/p>
&lt;p>Hugo的灵活性真的很棒，可以轻松实现各种布局需求。&lt;/p></description></item><item><title>生活感悟</title><link>https://mountainatic.github.io/memos/2025-08-10-life-thoughts/</link><pubDate>Sun, 10 Aug 2025 19:25:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-life-thoughts/</guid><description>&lt;p>今天阳光很好，坐在窗边工作的时候突然想到：&lt;/p>
&lt;p>编程其实很像生活，都需要不断地调试和优化。每一次的重构都是为了让代码（或生活）变得更好。&lt;/p>
&lt;p>有时候bug很难找，但解决的那一刻真的很有成就感！&lt;/p></description></item><item><title>读书笔记</title><link>https://mountainatic.github.io/memos/2025-08-10-reading-notes/</link><pubDate>Sun, 10 Aug 2025 19:20:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-reading-notes/</guid><description>&lt;p>今天读了一篇关于&amp;quot;刻意练习&amp;quot;的文章，有几个要点：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>专注练习&lt;/strong>：不是时间长度，而是练习的质量&lt;/li>
&lt;li>&lt;strong>即时反馈&lt;/strong>：需要能快速知道自己做得对不对&lt;/li>
&lt;li>&lt;strong>走出舒适区&lt;/strong>：总是挑战比当前水平稍高一点的任务&lt;/li>
&lt;/ol>
&lt;p>这对编程学习也很有启发，应该多做一些稍微超出当前能力的项目。&lt;/p>
&lt;p>#持续学习 #成长思维&lt;/p></description></item><item><title>美食记录</title><link>https://mountainatic.github.io/memos/2025-08-10-coffee-notes/</link><pubDate>Sun, 10 Aug 2025 19:15:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-coffee-notes/</guid><description>&lt;p>今天尝试了一个新的咖啡冲泡方法：&lt;/p>
&lt;p>&lt;strong>V60手冲咖啡&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>水温：92°C&lt;/li>
&lt;li>粉水比：1:15&lt;/li>
&lt;li>冲泡时间：2分30秒&lt;/li>
&lt;/ul>
&lt;p>味道比之前用法压壶做的要清香很多，酸度也更明显。下次可以试试不同的研磨度。&lt;/p>
&lt;p>☕️ 生活中的小实验总是很有趣&lt;/p></description></item><item><title>第一条想法</title><link>https://mountainatic.github.io/memos/2025-08-10-first-memo/</link><pubDate>Sun, 10 Aug 2025 18:30:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-first-memo/</guid><description>&lt;p>这是第一条静态 Memo！使用 Hugo 的内容管理系统，完全静态化。&lt;/p>
&lt;p>支持 &lt;strong>Markdown&lt;/strong> 语法，包括：&lt;/p>
&lt;ul>
&lt;li>列表&lt;/li>
&lt;li>&lt;code>代码&lt;/code>&lt;/li>
&lt;li>==高亮==&lt;/li>
&lt;/ul>
&lt;p>#静态化 #Hugo&lt;/p></description></item><item><title>学习笔记</title><link>https://mountainatic.github.io/memos/2025-08-10-study-notes/</link><pubDate>Sun, 10 Aug 2025 16:20:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-study-notes/</guid><description>&lt;p>今天配置了 Hugo 博客的各种功能：&lt;/p>
&lt;ol>
&lt;li>Obsidian 语法支持 ✅&lt;/li>
&lt;li>图片增强功能 ✅&lt;/li>
&lt;li>Memos 集成 ✅&lt;/li>
&lt;/ol>
&lt;p>感觉静态博客的灵活性真的很不错！&lt;/p>
&lt;p>#学习笔记 #博客&lt;/p></description></item><item><title>随想</title><link>https://mountainatic.github.io/memos/2025-08-10-random-thoughts/</link><pubDate>Sun, 10 Aug 2025 12:15:00 +0800</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-random-thoughts/</guid><description>&lt;p>从 Obsidian 迁移到 Hugo 真的很顺利，特别是语法兼容性做得很好。&lt;/p>
&lt;p>现在可以：&lt;/p>
&lt;ul>
&lt;li>在 Obsidian 中写作&lt;/li>
&lt;li>直接复制到 Hugo&lt;/li>
&lt;li>自动部署到 GitHub Pages&lt;/li>
&lt;/ul>
&lt;p>这个工作流程很棒！ 🎉&lt;/p></description></item><item><title>Example Text</title><link>https://mountainatic.github.io/posts/hello-world/</link><pubDate>Sat, 09 Aug 2025 08:00:00 +0900</pubDate><guid>https://mountainatic.github.io/posts/hello-world/</guid><description>&lt;p>这是第一篇文章，用来测试各项功能是否正常工作。&lt;/p>
&lt;h2 id="1-latex-数学公式">1. LaTeX 数学公式
&lt;/h2>&lt;p>行内公式：爱因斯坦的质能方程是 $E=mc^2$。&lt;/p>
&lt;p>块级公式（支持编号）：
$$
i\hbar\frac{\partial}{\partial t}\Psi(\mathbf{r},t) = \left [ -\frac{\hbar^2}{2m}\nabla^2 + V(\mathbf{r},t) \right ]\Psi(\mathbf{r},t) \tag{薛定谔方程}
$$&lt;/p>
&lt;h2 id="2-mermaid-图表">2. Mermaid 图表
&lt;/h2>&lt;script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js">&lt;/script>
&lt;script>
document.addEventListener('DOMContentLoaded', function() {
mermaid.initialize({
startOnLoad: true,
theme: 'default',
securityLevel: 'loose'
});
});
&lt;/script>&lt;div class="mermaid">
graph TD;
A[开始搭建] --> B{遇到 Bug 🐞};
B --> C[调试环境];
C --> D[修复模板];
D --> E[成功! ✨];
&lt;/div>
&lt;h2 id="3-代码高亮">3. 代码高亮
&lt;/h2>&lt;p>下面是一段 Python 代码：&lt;/p>
&lt;h2 id="4-插入图片">4. 插入图片
&lt;/h2>&lt;p>首先，把你的图片（例如 &lt;code>my-image.png&lt;/code>）放到项目的 &lt;code>static/img/&lt;/code> 目录下。然后就可以像下面这样引用它：&lt;/p>
&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example.png"
loading="lazy"
alt="这是一张流程图的快照"
class="responsive-image"
>
&lt;figcaption>这是一张流程图的快照&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="5-obsidian-扩展语法">5. Obsidian 扩展语法
&lt;/h2>&lt;p>==这段文字会被高亮显示==&lt;/p>
&lt;h3 id="默认状态测试">默认状态测试
&lt;/h3>&lt;blockquote>
&lt;p>[!NOTE]
这是一个标准的、默认展开的笔记。&lt;/p>
&lt;/blockquote>
&lt;h3 id="折叠状态测试">折叠状态测试
&lt;/h3>&lt;blockquote>
&lt;p>[!NOTE+]
这一个用 &lt;code>+&lt;/code> 指定，也应该是默认展开的。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!NOTE-]
&lt;strong>这一个用 &lt;code>-&lt;/code> 指定，应该是默认折叠的，你需要点击才能看到我。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h3 id="别名和大小写测试">别名和大小写测试
&lt;/h3>&lt;blockquote>
&lt;p>[!Warning] 这是一个警告
&lt;code>Warning&lt;/code> (W大写) 应该能被正确识别。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!caution] 这还是一个警告
&lt;code>caution&lt;/code> 是 &lt;code>warning&lt;/code> 的一个别名。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!success] 任务完成
&lt;code>success&lt;/code> 和 &lt;code>check&lt;/code>, &lt;code>done&lt;/code> 都是成功样式的别名。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!QUESTION] 常见问题
&lt;code>QUESTION&lt;/code> 和 &lt;code>faq&lt;/code> 都是问题样式的别名。&lt;/p>
&lt;/blockquote></description></item><item><title>Obsidian 语法测试 - Obsidian 风格</title><link>https://mountainatic.github.io/posts/obsidian-native-style-test/</link><pubDate>Mon, 15 Jan 2024 12:00:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/obsidian-native-style-test/</guid><description>&lt;h2 id="obsidian-callouts类似-obsidian-的卡片风格">Obsidian Callouts（类似 Obsidian 的卡片风格）
&lt;/h2>&lt;blockquote>
&lt;p>[!NOTE]
这是一个基础的 Note callout，现在使用类似 Obsidian 的卡片风格设计。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!TIP] 自定义标题的提示
这是带有自定义标题的 Tip callout，具有独特的颜色和图标。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!WARNING]
这是一个警告类型的 callout，使用橙色主题。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!DANGER]
这是一个危险类型的 callout，使用红色主题表示严重警告。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!ERROR]
这是一个错误类型的 callout，同样使用红色主题。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!SUCCESS]
这是一个成功类型的 callout，使用绿色主题表示积极信息。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!QUESTION]
这是一个问题类型的 callout，使用紫色主题。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!EXAMPLE]
这是一个示例类型的 callout，使用青色主题展示示例内容。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!BUG]
这是一个 Bug 类型的 callout，用于标记已知问题。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!QUOTE]
这是一个引用类型的 callout，适合展示引文或重要声明。&lt;/p>
&lt;/blockquote>
&lt;h2 id="原生-blockquote">原生 Blockquote
&lt;/h2>&lt;p>这是普通的 blockquote 用于对比：&lt;/p>
&lt;blockquote>
&lt;p>这是一个标准的 blockquote&lt;/p>
&lt;p>它使用 Stack 主题的原生样式&lt;/p>
&lt;p>与 Obsidian callouts 形成对比&lt;/p>
&lt;/blockquote>
&lt;h2 id="obsidian-高亮语法测试">Obsidian 高亮语法测试
&lt;/h2>&lt;p>这是一段包含 ==高亮文本== 的段落，应该显示为黄色背景。&lt;/p>
&lt;p>普通文本 ==重要信息== 更多普通文本 ==另一个高亮== 结束。&lt;/p>
&lt;p>多个高亮在同一行：==第一个== 和 ==第二个== 和 ==第三个==。&lt;/p>
&lt;p>==整段高亮的文字可能会很长，用来测试换行和样式的表现==。&lt;/p>
&lt;h2 id="mermaid-图表">Mermaid 图表
&lt;/h2>&lt;script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js">&lt;/script>
&lt;script>
document.addEventListener('DOMContentLoaded', function() {
mermaid.initialize({
startOnLoad: true,
theme: 'default',
securityLevel: 'loose'
});
});
&lt;/script>&lt;div class="mermaid">
graph TD
A[Obsidian 风格] --> B[更好的视觉体验]
A --> C[卡片式设计]
B --> D[完美的用户体验]
C --> D
E[高亮语法] --> F[重要信息]
F --> G[视觉突出]
G --> H[增强可读性]
&lt;/div>
&lt;p>现在的 Obsidian callouts 采用了类似 Obsidian 的卡片风格，提供更好的视觉层次和用户体验！&lt;/p>
&lt;h2 id="图片功能测试">图片功能测试
&lt;/h2>&lt;h3 id="基础图片自适应大小">基础图片（自适应大小）
&lt;/h3>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example.png"
loading="lazy"
alt="测试图片"
class="responsive-image"
>
&lt;figcaption>测试图片&lt;/figcaption>
&lt;/figure>
&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example_1.png"
loading="lazy"
alt="测试图片"
class="responsive-image"
>
&lt;figcaption>测试图片&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="指定宽度的图片">指定宽度的图片
&lt;/h3>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example.png"
loading="lazy"
alt="指定宽度:100|100"
class="responsive-image"
>
&lt;figcaption>指定宽度:100|100&lt;/figcaption>
&lt;/figure>
&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example_1.png"
loading="lazy"
alt="指定宽度:400|400"
class="responsive-image"
>
&lt;figcaption>指定宽度:400|400&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="指定宽高的图片">指定宽高的图片
&lt;/h3>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example.png"
loading="lazy"
alt="指定宽高:100x900|100x300"
class="responsive-image"
>
&lt;figcaption>指定宽高:100x900|100x300&lt;/figcaption>
&lt;/figure>
&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example_1.png"
loading="lazy"
alt="指定宽高:300x100|300x100"
class="responsive-image"
>
&lt;figcaption>指定宽高:300x100|300x100&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="小尺寸内联图片">小尺寸内联图片
&lt;/h3>&lt;p>这是一段文字 &lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example.png"
loading="lazy"
alt="小图标:100|100"
class="responsive-image"
>
&lt;figcaption>小图标:100|100&lt;/figcaption>
&lt;/figure>
&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/img/Example_1.png"
loading="lazy"
alt="小图标:50|50"
class="responsive-image"
>
&lt;figcaption>小图标:50|50&lt;/figcaption>
&lt;/figure>
包含小图片的演示。&lt;/p>
&lt;h3 id="图片功能说明">图片功能说明
&lt;/h3>&lt;ul>
&lt;li>✅ &lt;strong>自适应大小&lt;/strong>：图片会根据容器宽度自动调整&lt;/li>
&lt;li>✅ &lt;strong>响应式设计&lt;/strong>：在不同设备上都有良好的显示效果&lt;/li>
&lt;li>✅ &lt;strong>点击放大&lt;/strong>：点击图片可以全屏查看&lt;/li>
&lt;li>✅ &lt;strong>尺寸控制&lt;/strong>：支持 Obsidian 风格的尺寸语法 &lt;code>![alt|width]&lt;/code> 或 &lt;code>![alt|widthxheight]&lt;/code>&lt;/li>
&lt;li>✅ &lt;strong>图片说明&lt;/strong>：自动显示图片的 alt 文本作为说明&lt;/li>
&lt;li>✅ &lt;strong>阴影效果&lt;/strong>：图片有精美的阴影和悬浮效果&lt;/li>
&lt;li>✅ &lt;strong>默认大小&lt;/strong>：400px自适应&lt;/li>
&lt;/ul></description></item><item><title>调试测试</title><link>https://mountainatic.github.io/posts/debug-test/</link><pubDate>Mon, 15 Jan 2024 12:00:00 +0800</pubDate><guid>https://mountainatic.github.io/posts/debug-test/</guid><description>&lt;h2 id="测试-callout-原始语法">测试 Callout (原始语法)
&lt;/h2>&lt;blockquote>
&lt;p>[!NOTE]
这是一个简单的测试&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!WARNING]
警告测试&lt;/p>
&lt;/blockquote>
&lt;p>对应代码为&lt;/p>
&lt;h2 id="测试-callout-shortcode">测试 Callout (Shortcode)
&lt;/h2>&lt;div class="obsidian-callout obsidian-callout-note">
&lt;div class="obsidian-callout-title">
&lt;span class="obsidian-callout-icon">📝&lt;/span>
&lt;span class="obsidian-callout-title-text">Note&lt;/span>
&lt;/div>
&lt;div class="obsidian-callout-content">
这是使用 shortcode 的 Note
&lt;/div>
&lt;/div>
&lt;div class="obsidian-callout obsidian-callout-warning">
&lt;div class="obsidian-callout-title">
&lt;span class="obsidian-callout-icon">⚠️&lt;/span>
&lt;span class="obsidian-callout-title-text">Warning&lt;/span>
&lt;/div>
&lt;div class="obsidian-callout-content">
这是使用 shortcode 的 Warning
&lt;/div>
&lt;/div>
&lt;p>对应代码为&lt;/p>
&lt;h2 id="测试高亮">测试高亮
&lt;/h2>&lt;p>这是 ==高亮测试== 文本。&lt;/p></description></item><item><title/><link>https://mountainatic.github.io/memos/2025-08-10-code-snippets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mountainatic.github.io/memos/2025-08-10-code-snippets/</guid><description/></item></channel></rss>