<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>8051-MCU on Mountainatic's Blog</title><link>https://mountainatic.github.io/categories/8051-mcu/</link><description>Recent content in 8051-MCU on Mountainatic's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Mountainatic</copyright><lastBuildDate>Mon, 11 Aug 2025 22:54:29 +0800</lastBuildDate><atom:link href="https://mountainatic.github.io/categories/8051-mcu/index.xml" rel="self" type="application/rss+xml"/><item><title>C51简述</title><link>https://mountainatic.github.io/posts/c51%E7%AE%80%E8%BF%B0/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/c51%E7%AE%80%E8%BF%B0/</guid><description>&lt;h2 id="规则类怪谈">规则类怪谈
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>主函数内部第一层必须是 &lt;code>while(1){}&lt;/code>：
因为嵌入式是实时系统，没有操作系统帮他进行下一步操作（个人感觉参考图灵机只有执行程序和停机状态，停机就是关机下），不一直循环会导致 51 进入异常状态，里面就写一套工作流，最后回到开头等输入就行&lt;/strong>&lt;/li>
&lt;li>&lt;strong>除了上面，当然也可以使用中断触发 + 空闲循环&lt;/strong>&lt;/li>
&lt;li>&lt;strong>延时函数：&lt;/strong>
&lt;strong>因为输入的是高低电平，开始时候不稳定，常常需要消抖等操作
会写这样：&lt;/strong>
&lt;/li>
&lt;li>&lt;strong>主程序永远是 void main ()，没有东西会接收他的返回&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="特殊数据类型">特殊数据类型
&lt;/h2>&lt;ul>
&lt;li>
&lt;h3 id="数据存储区关键字">&lt;strong>数据存储区关键字&lt;/strong>
&lt;/h3>&lt;p>&lt;em>&lt;strong>==存储结构中包含多种不同的存储区（如片内 RAM、片外 RAM、片内 ROM）。C51 语言通过关键字指定变量存储的位置==&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>==一般来说，编译器会 自动分配内存 ==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==比如：局部变量到低 128、全局变量低 128-高 128、大数据或者数组可能需要手动指定到 &lt;code>xdata&lt;/code> 或者 &lt;code>idata&lt;/code> ==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==一般来说，Kail 可能更倾向于先去用光低 128（包括空闲的工作寄存器组）==&lt;/strong>&lt;/em>
&lt;em>&lt;strong>==也就是低 128 （正常区 &amp;gt; 非激活的工作寄存器区 &amp;gt; 位寻址区）&amp;gt; 高 128（idata）&amp;gt; xdata==&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>不知道存储器结构的看 -&amp;gt; &lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b%e5%ad%98%e5%82%a8%e5%99%a8%e9%83%a8%e5%88%86/" >因你而在的故事#存储器部分&lt;/a>&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;code>data&lt;/code>
&lt;ul>
&lt;li>片内 RAM（0x00 - 0x7F）&lt;/li>
&lt;li>访问速度最快，适合存储经常访问的局部变量。&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>idata&lt;/code>
&lt;ul>
&lt;li>片内 RAM 的 0x80 - 0xFF 地址（间接寻址区域)&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>xdata&lt;/code>
&lt;ul>
&lt;li>片外扩展 RAM&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>code&lt;/code>
&lt;ul>
&lt;li>片内 ROM，用于存储常量或不可修改的数据&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>bit&lt;/code>
&lt;ul>
&lt;li>存放在特殊的位寻址区域（0x20 - 0x2F）。&lt;/li>
&lt;li>每个变量只占用 1 位，适合存储布尔值。&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Question]+ 为什么需要这么多关键字划分 RAM？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>8051 内部 RAM 主要分成三部分：&lt;/p>
&lt;ol>
&lt;li>直接寻址区—— &lt;code>data&lt;/code>
直接寻址最快，==受 CPU 指令集限制，只能直接访问 128 字节的 data 区==&lt;/li>
&lt;li>间接寻址区—— &lt;code>idata&lt;/code>
通过访问寄存器 &lt;strong>R0 或 R1&lt;/strong> 进行间接寻址&lt;/li>
&lt;li>特殊功能寄存器区（SFR）
这里的地址和 idata 的高 128 字节重叠，但通过不同的寻址方式区分（直接寻址访问 SFR，间接寻址访问 idata 的高 128 字节）&lt;/li>
&lt;/ol>
&lt;p>==也就是什么呢，&lt;code>idata&lt;/code> 区在 &lt;code>data&lt;/code> 区前，&lt;code>data&lt;/code> 是 前 128 Bytes，后 128 Bytes 叫&lt;strong>高 128 Bytes&lt;/strong>，间接寻址访问，直接寻址后 128 Bytes 访问到的是 SFR==&lt;/p>
&lt;p>0x00 - 0x7F 是 data 区，0x80 - 0xFF 表为 SFR，里是 idata 区&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 间接寻址怎么寻？&lt;/p>
&lt;ol>
&lt;li>使用寄存器 R0 或者 R1 存储目标地址&lt;/li>
&lt;li>通过寄存器间接访问
也就是：&lt;/li>
&lt;/ol>
&lt;p>C 可以智能存入，汇编层面，指针就是 R0/R1 寄存器&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 说了半天，R0 和 R1 是哪里的寄存器？
实际上，片内 RAM 的 &lt;code>data&lt;/code> 区可以更加细分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>工作寄存器区（低 32 Bytes，0x30 - 0x7F）&lt;/p>
&lt;ul>
&lt;li>每组 8 个寄存器，共有 4 组，分别存储在地址范围 0x00 ~ 0x1F&lt;/li>
&lt;li>==寄存器按组启用，每次只能启用一个完整的寄存器组==，具体由 PSW 的 RS1 和 RS0 决定 &lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b%e8%bf%90%e7%ae%97%e6%8e%a7%e5%88%b6%e9%83%a8%e5%88%86/" >因你而在的故事#运算控制部分 &lt;/a>
&lt;strong>RS1 = 0, RS0 = 0&lt;/strong>：启用组 0（地址范围 0x00 ~ 0x07）
&lt;strong>RS1 = 0, RS0 = 1&lt;/strong>：启用组 1（地址范围 0x08 ~ 0x0F）
&lt;strong>RS1 = 1, RS0 = 0&lt;/strong>：启用组 2（地址范围 0x10 ~ 0x17）
&lt;strong>RS1 = 1, RS0 = 1&lt;/strong>：启用组 3（地址范围 0x18 ~ 0x1F）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>R0&lt;/strong>和&lt;strong>R1&lt;/strong>这些只是每回启用的组中的寄存器的代号罢了，叫 &lt;strong>R0-R7&lt;/strong>
&lt;em>&lt;strong>==当然是有特殊情况的，多任务切换或者中断嵌套调用中可能会用多个寄存器组==&lt;/strong>&lt;/em>&lt;/p>
&lt;ul>
&lt;li>除了正在被当作工作寄存器使用的组外，其他都可以当普通 RAM 使用&lt;/li>
&lt;li>动态切换寄存器组时，其他组的内容会保留。&lt;/li>
&lt;li>可以通过地址直接访问非激活组中的寄存器：&lt;/li>
&lt;li>
&lt;/li>
&lt;/ul>
&lt;p>unsigned char data *ptr; //定义指针变量
unsigned char temp;
ptr = (unsigned char *) 0x08; //指针指向组 1 起始地址
*ptr = 0x55;
temp = *(ptr+1); //读取组 1 的第二个寄存器内容
P1 = temp; //输出到 P1 口```&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可位寻址区（128&lt;strong>位&lt;/strong>，0x20 - 0x2F）&lt;/p>
&lt;ul>
&lt;li>一般来说用作存储布尔型变量、标志位等纯逻辑变量，按&lt;strong>位&lt;/strong>读取写入&lt;/li>
&lt;li>必要时也可存储普通变量，按&lt;strong>字节&lt;/strong>读取写入&lt;/li>
&lt;li>定向引用得要汇编/位操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>普通 RAM 区（低 80 Bytes，0x30 - 0x7F）&lt;/p>
&lt;ul>
&lt;li>局部变量、全局变量、堆栈指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;h3 id="特殊变量类型">特殊变量类型
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>sbit&lt;/code> 特殊位变量&lt;/strong>
用于访问 SFR 或者位地址，详细的说是 ==将位地址绑定到一个变量==&lt;/p>
&lt;p>绑定到位寻址区：&lt;code>sbit varible = adresss^number&lt;/code>
绑定到 SFR：&lt;code>sbit varible = SFR名字^位序号&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>sfr&lt;/code> 特殊功能寄存器&lt;/strong>
用于将 SFR 中的寄存器地址绑定到变量（比如把 0x90 绑定到 P1）
一般现代 C51 编译器已经预制，==无需重复定义==
只能绑定 0x80 - 0xFF（也就是 SFR 内部）
&lt;code>sfr&lt;/code> 只能定义 1 Byte 的寄存器
用 SFR 定义的&lt;strong>表示完整八位的地址&lt;/strong>的变量，只能&lt;strong>按字节读写&lt;/strong>，如需逐位操作需要结合 &lt;code>sbit&lt;/code> 使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>操纵各位电平&lt;/strong>
例如：&lt;code>P1 = 0xFF&lt;/code> 将 P1 的所有引脚设置为高电平
==每个字节是打包设置各个位的==
0xFF 是 16 进制数，转换为二进制就是 1111 1111&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Question]+ 什么是位地址？&lt;/p>
&lt;ul>
&lt;li>&lt;strong>位地址允许对单个==位==进行访问和操作&lt;/strong>&lt;/li>
&lt;li>&lt;strong>每个位地址唯一标识 RAM 或 SFR 的某一具体位，范围为 0x00 ~ 0x7F，即支持 128 个位地址&lt;/strong>&lt;/li>
&lt;li>&lt;strong>分为两类：&lt;/strong>
&lt;ol>
&lt;li>位寻址区中的位地址（0x20 - 0x2F）-&amp;gt;（0x00 - 0x7F）&lt;/li>
&lt;li>SFR 中的位地址（0x80 - 0xFF）
&lt;ul>
&lt;li>但是某些 SFR 位置支持直接访问&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>也就是什么呢，位地址把字节地址又细分，给每个位都分配了地址，8 个位地址长度=1 个正常地址，也就是所谓的==映射==&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 那 &lt;code>sbit&lt;/code> 和 &lt;code>bit&lt;/code> 在位寻址区有啥区别？
你要想清楚，&lt;code>sbit&lt;/code> 是把那个==位==&lt;strong>绑定到变量&lt;/strong>进行操作，&lt;code>bit&lt;/code> 是一个位变量，被&lt;strong>分配&lt;/strong>到了位寻址区，这两个建立联系过程是&lt;strong>相反&lt;/strong>的，并且 &lt;code>bit&lt;/code> 不一定会分配到特定的位上&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!Question]+ 那位地址有啥用？没看见用啊？
位地址在汇编中才能用，C 代码那种编译时候也会转成汇编用位地址写
如汇编的啥 &lt;code>SETB&lt;/code>、&lt;code>CLR&lt;/code>、&lt;code>JB , label&lt;/code>、&lt;code>JNB ， label&lt;/code>
在汇编文档中还会有 &lt;code>0**H&lt;/code> 这种写法，和 &lt;code>0x**&lt;/code> 是等同的，16 进制数&lt;/p>
&lt;/blockquote>
&lt;h2 id="延时与硬件操作">延时与硬件操作
&lt;/h2></description></item><item><title>SFR 主要部件</title><link>https://mountainatic.github.io/posts/sfr-%E4%B8%BB%E8%A6%81%E9%83%A8%E4%BB%B6/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/sfr-%E4%B8%BB%E8%A6%81%E9%83%A8%E4%BB%B6/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>地址&lt;/th>
&lt;th>SFR 名称&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x80&lt;/td>
&lt;td>P0&lt;/td>
&lt;td>端口 0 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x81&lt;/td>
&lt;td>SP&lt;/td>
&lt;td>堆栈指针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x87&lt;/td>
&lt;td>PCON&lt;/td>
&lt;td>电源控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x88&lt;/td>
&lt;td>TCON&lt;/td>
&lt;td>定时器控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x89&lt;/td>
&lt;td>TMOD&lt;/td>
&lt;td>定时器模式寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90&lt;/td>
&lt;td>P1&lt;/td>
&lt;td>端口 1 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xA0&lt;/td>
&lt;td>P2&lt;/td>
&lt;td>端口 2 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xB0&lt;/td>
&lt;td>P3&lt;/td>
&lt;td>端口 3 I/O 控制寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xD0&lt;/td>
&lt;td>PSW&lt;/td>
&lt;td>程序状态字寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xE0&lt;/td>
&lt;td>ACC&lt;/td>
&lt;td>累加器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0xF0&lt;/td>
&lt;td>B&lt;/td>
&lt;td>B 寄存器&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>全字节访问 &lt;code>P1 = 0xFF;&lt;/code>&lt;/strong>&lt;/li>
&lt;li>**逐位访问 &lt;code>sbit LED = P1^0;&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>STC89C52RC单片机</title><link>https://mountainatic.github.io/posts/stc89c52rc%E5%8D%95%E7%89%87%E6%9C%BA/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/stc89c52rc%E5%8D%95%E7%89%87%E6%9C%BA/</guid><description>&lt;h2 id="参数">参数
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>工作电压&lt;/strong>：5.5~3.5 V&lt;/li>
&lt;li>&lt;strong>Flash 存储器&lt;/strong>：8 K&lt;/li>
&lt;li>&lt;strong>SRAM&lt;/strong>：512 Bytes&lt;/li>
&lt;li>&lt;strong>5 K EEPROM&lt;/strong>、8 扇区 2000 h~2 FFFh&lt;/li>
&lt;li>&lt;strong>三个定时器&lt;/strong>&lt;/li>
&lt;li>&lt;strong>没有 A/D&lt;/strong>&lt;/li>
&lt;li>&lt;strong>10 位 8 路有降低 EMI&lt;/strong>&lt;/li>
&lt;li>&lt;strong>是双倍速&lt;/strong>&lt;/li>
&lt;li>&lt;strong>39 个 I/O 口&lt;/strong>&lt;/li>
&lt;li>&lt;strong>4 个支持掉电唤醒&lt;/strong>&lt;/li>
&lt;li>&lt;strong>外部中断&lt;/strong>：有复位、看门狗、ISP、IAP&lt;/li>
&lt;/ul>
&lt;h2 id="结构简介">结构简介
&lt;/h2>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/images/origin.png"
loading="lazy"
alt="origin.png"
class="responsive-image"
>
&lt;figcaption>origin.png&lt;/figcaption>
&lt;/figure>
&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/images/real.png"
loading="lazy"
alt="real.png"
class="responsive-image"
>
&lt;figcaption>real.png&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="cpu">CPU
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>位数&lt;/strong>：8 位&lt;/li>
&lt;li>&lt;strong>峰值速度&lt;/strong>：12 时钟周期/机器周期&lt;/li>
&lt;li>&lt;strong>组成&lt;/strong>：运算器，控制器，支持位处理（用于控制）&lt;/li>
&lt;/ul>
&lt;h3 id="存储器">存储器
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Flash ROM&lt;/strong>：8 KB，用于存放用户代码和常量，支持在线编程（ISP/IAP）&lt;/li>
&lt;li>&lt;strong>Data Flash（可用作 EEPROM）&lt;/strong>：9 KB，用于保存不是特别频繁更新的数据，如配置参数、校准值等，擦写寿命 10 w+，有多个扇区，建议一次修改的放同一个&lt;/li>
&lt;li>&lt;strong>RAM&lt;/strong>：256 Bytes，其中低 128 Bytes 为用户可访问，另外 128 Bytes 为高 128 Bytes
&lt;ul>
&lt;li>&lt;strong>高 128 Bytes RAM&lt;/strong> 与特殊功能寄存器共用相同地址范围，但物理上独立，高 RAM 只能间接寻址，SFRs 可以直接寻址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="外部存储器接口">外部存储器接口
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>外部程序存储器&lt;/strong>：可通过 EA 引脚选择是否启用外部程序存储器，启用外部程序存储器后，复位后会从外部存储器的第一个地址开始取指令执行。&lt;/li>
&lt;li>&lt;strong>外部数据存储器&lt;/strong>：提供额外的数据存储空间，最大可达 64 KB。&lt;/li>
&lt;/ul>
&lt;h3 id="输入输出端口-io-ports-p-0---p-3-端口">输入输出端口 (I/O Ports) P 0 - P 3 端口
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>数量&lt;/strong>：4 个 8 位并行 I/O 端口（P 0、P 1、P 2、P 3）&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：每个端口可以独立设置为输入或输出，并且具有多种复用功能（如 P 3 端口的引脚还可用作串行通信、中断输入等）&lt;/li>
&lt;li>&lt;strong>特性&lt;/strong>：部分引脚具备第二功能，例如定时器、串行通信、中断等&lt;/li>
&lt;/ul>
&lt;h3 id="定时计数器">定时/计数器
&lt;/h3>&lt;h4 id="定时器计数器-t-0-和-t-1">定时器/计数器 T 0 和 T 1
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>类型&lt;/strong>：16 位定时器/计数器&lt;/li>
&lt;li>&lt;strong>模式&lt;/strong>：支持多种工作模式，包括定时模式和计数模式&lt;/li>
&lt;li>&lt;strong>用途&lt;/strong>：用于测量时间间隔或计算事件次数&lt;/li>
&lt;/ul>
&lt;h4 id="定时器-t-2">定时器 T 2
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>类型&lt;/strong>：额外的 16 位定时器/计数器&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>：可以作为捕捉模式或波特率发生器使用&lt;/li>
&lt;/ul>
&lt;h3 id="中断系统">中断系统
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>中断源&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>外部中断 INT 0 和 INT 1&lt;/strong>：分别由 P 3.2 和 P 3.3 引脚触发&lt;/li>
&lt;li>&lt;strong>定时器中断&lt;/strong>：来自 T 0、T 1 和 T 2 的溢出中断&lt;/li>
&lt;li>&lt;strong>串行口中断&lt;/strong>：用于接收和发送数据完成时触发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优先级&lt;/strong>：支持两级中断优先级，可以灵活配置中断响应顺序&lt;/li>
&lt;/ul>
&lt;h3 id="串行通信接口-uart通用异步收发传输器">串行通信接口 UART（通用异步收发传输器）
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：支持全双工串行通信，适用于与计算机或其他设备交换数据&lt;/li>
&lt;li>&lt;strong>波特率&lt;/strong>：可通过定时器设置不同的波特率&lt;/li>
&lt;/ul>
&lt;h3 id="电源管理和复位电路">电源管理和复位电路
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>电源管理&lt;/strong>：支持低功耗模式，如空闲模式和掉电模式，以节省能源&lt;/li>
&lt;li>&lt;strong>复位电路&lt;/strong>：包含上电复位和手动复位功能，确保单片机在启动或异常情况下恢复正常操作&lt;/li>
&lt;/ul>
&lt;h3 id="其他特性">其他特性
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>看门狗定时器 (WDT)&lt;/strong>：防止程序跑飞，自动重启单片机&lt;/li>
&lt;li>&lt;strong>低压检测 (LVD)&lt;/strong>：监控电源电压，当电压低于设定阈值时产生中断或复位&lt;/li>
&lt;li>&lt;strong>In-Application Programming (IAP)&lt;/strong>：允许应用程序对内部 Flash 进行读写操作，实现动态更新固件的功能&lt;/li>
&lt;/ul>
&lt;h2 id="引脚介绍">引脚介绍
&lt;/h2>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/posts/structurepng/"
loading="lazy"
alt="500"
class="responsive-image"
>
&lt;figcaption>500&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="电源引脚">电源引脚
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Vcc&lt;/strong>：电源正极&lt;/li>
&lt;li>&lt;strong>Vss / Gnd&lt;/strong>：负极，接地&lt;/li>
&lt;/ul>
&lt;h3 id="时钟引脚">时钟引脚
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>XTAL 1&lt;/strong>：
&lt;ul>
&lt;li>a. 内部时钟电路反相放大器输入端，接外部晶振引脚之一&lt;/li>
&lt;li>b. 使用外部时钟源时候，该引脚为输入源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>XTAL 2&lt;/strong>：
&lt;ul>
&lt;li>a. 内部时钟电路反相放大器输出端，接外部晶振引脚之一&lt;/li>
&lt;li>b. 使用外部时钟源时候，该引脚可直接浮空&lt;/li>
&lt;li>带 &amp;ldquo;RC&amp;rdquo; 后缀一般自带==内部 RC 时钟==，可以通过配置 SFRs 启用
&lt;ul>
&lt;li>可以通过==外接晶振==+==反相放大器==实现 “半内部时钟源”，具体就是 XTAL 1 进 XTAL 2 出（在这套系统彻底启动前，即所谓的 “振荡器启动时间” ，RC 时钟会代替产生信号）&lt;/li>
&lt;li>（基本都会有 RC 时钟，没有的可能会用 delay ()，或者看门狗，等待，上电复位等手段解决）&lt;/li>
&lt;li>也可以直接由 XTAL 1 接入==外部时钟源==&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="控制引脚">控制引脚
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>RST&lt;/strong>： 在引脚上施加持续时间大于两个机器周期（对于该单片机准确来说是 24 个时钟+10 us）的高电平来复位（通常是通过连接到 Vcc） 正常工作时电平应该&amp;lt;=0.5 V&lt;/li>
&lt;li>&lt;em>&lt;em>EA&lt;/em>/Vpp（Enable Address/Voltage Pulse of Programming）&lt;/em>*
&lt;ul>
&lt;li>
&lt;p>a. 外部程序存储器访问允许控制端（实际上控制的是内部存储器）&lt;/p>
&lt;ul>
&lt;li>&lt;em>&lt;em>EA&lt;/em> = 0（低电平 —— 接地，就连接到 GND）&lt;/em>*，仅读取外部存储器内容（0000 H~FFFFH），片内 8 K 的程序存储器被禁用&lt;/li>
&lt;li>&lt;em>&lt;em>EA&lt;/em> = 1（高电平 —— 一般是连接到 Vcc）&lt;/em>*，==优先读取片内程序 ==在 PC 值（程序计数器中存放的数值，就是下一条指令的地址）不超出片上 8 KB Flash（即 1 FFFH）时，单片机只读取该 Flash 内容==超出去自动转向片外存储器==&lt;/li>
&lt;li>&lt;strong>b. Vpp&lt;/strong>：对片内 Flash 编程，接编程电压&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>注意：版本不一样&lt;/p>
&lt;ul>
&lt;li>HD 版本和 90 C 版本内部都集成了 MAX 810 复位电路，但时钟频率为 6 MHz 时候该复位电路可靠，12 MHz 勉强可用&lt;/li>
&lt;li>HD 版有 PSEN、ALE 和 EA 管脚没有 P 4.4/. 5/. 6 口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>画板子</title><link>https://mountainatic.github.io/posts/%E7%94%BB%E6%9D%BF%E5%AD%90/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E7%94%BB%E6%9D%BF%E5%AD%90/</guid><description>&lt;h3 id="三极管">三极管
&lt;/h3>&lt;p>&lt;strong>主要有基极 Base、集电极 Collector、发射极 Emitter组成&lt;/strong>
![Pasted image 20250205112937.jpg](/images/Pasted image 20250205112937.jpg)&lt;/p>
&lt;h4 id="npn-型">NPN 型
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>简称 N 型，基极电压必须高于发射极电压才能导通，电流由集电极 → 发射极&lt;/strong>&lt;/li>
&lt;li>&lt;strong>常用于==低侧驱动==，适合 LED、继电器等&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="pnp-型">PNP 型
&lt;/h4>&lt;ul>
&lt;li>**简称 P 型，基极电压必须低于发射极电压，一般由发射极 → 集电极&lt;/li>
&lt;li>&lt;strong>常用于==高侧驱动==，适合电机等大功率设备&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>有三种工作模式, 截止区、放大区、饱和区&lt;/strong>&lt;/p></description></item><item><title>简述</title><link>https://mountainatic.github.io/posts/%E7%AE%80%E8%BF%B0/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E7%AE%80%E8%BF%B0/</guid><description>&lt;h2 id="建议路径">建议路径：
&lt;/h2>&lt;ol>
&lt;li>学 C 语言（学校肯定教，知道基础的就行，起码三类结构啥的得清楚）&lt;/li>
&lt;li>首先知道冯 · 依诺曼机和图灵机，有个大概印象&lt;/li>
&lt;li>看&lt;a class="link" href="https://mountainatic.github.io/posts/%e5%9b%a0%e4%bd%a0%e8%80%8c%e5%9c%a8%e7%9a%84%e6%95%85%e4%ba%8b/" >因你而在的故事&lt;/a>这个，对着原理图看每个部分的介绍&lt;/li>
&lt;li>看 &lt;a class="link" href="https://mountainatic.github.io/posts/c51%e7%ae%80%e8%bf%b0/" >C51简述&lt;/a>，知道 RAM 的精妙用处，会（起码知道原理，查表能查出来）定义变量、会通过 SFR 控制引脚（还不用知道具体有哪些）&lt;/li>
&lt;li>看引脚介绍&lt;/li>
&lt;/ol></description></item><item><title>设计方案</title><link>https://mountainatic.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</guid><description>&lt;h3 id="第一步需求分析">第一步：需求分析
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>基础功能&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用步进电机模拟洗衣机桶的旋转。&lt;/li>
&lt;li>使用数码管显示剩余时间或当前状态。&lt;/li>
&lt;li>使用独立按键控制洗衣机的启动/停止。&lt;/li>
&lt;li>使用 LED 灯显示当前的工作阶段（如进水、浸泡、洗衣、脱水、结束）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>扩展功能&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>实现紧急停止功能，当按下特定按键时立即停止所有操作。&lt;/li>
&lt;li>如果有光敏电阻，检测光线强度以决定是否允许洗衣机工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="第二步硬件选择与连接">第二步：硬件选择与连接
&lt;/h3>&lt;h4 id="硬件组件选择">硬件组件选择
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>步进电机&lt;/strong>：选择适合的步进电机（如 28 BYJ-48），并准备相应的驱动芯片（如 ULN 2003）。&lt;/li>
&lt;li>&lt;strong>数码管&lt;/strong>：选择 7 段数码管用于显示时间或状态信息。&lt;/li>
&lt;li>&lt;strong>独立按键&lt;/strong>：准备两个独立按键，一个用于启动洗衣机，另一个用于紧急停止。&lt;/li>
&lt;li>&lt;strong>LED 灯&lt;/strong>：准备四个 LED 灯来指示不同的工作阶段。&lt;/li>
&lt;li>&lt;strong>蜂鸣器&lt;/strong>（可选）：用于提醒用户洗衣机的状态变化。&lt;/li>
&lt;li>&lt;strong>光敏电阻&lt;/strong>（可选）：用于检测环境光线强度。&lt;/li>
&lt;/ul>
&lt;h4 id="硬件连接">硬件连接
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>步进电机&lt;/strong>：将步进电机的引脚连接到驱动芯片的输出端，再将驱动芯片的输入端连接到 51 单片机的 GPIO 口。&lt;/li>
&lt;li>&lt;strong>数码管&lt;/strong>：如果数码管较多，可以通过移位寄存器（如 74 HC 595）减少单片机的 GPIO 占用。将数码管的段选线连接到移位寄存器的输出端，控制线连接到单片机。&lt;/li>
&lt;li>&lt;strong>独立按键&lt;/strong>：按键的一端接地，另一端通过上拉电阻连接到 51 单片机的 GPIO 口。&lt;/li>
&lt;li>&lt;strong>LED 灯&lt;/strong>：每个 LED 灯连接到单片机的一个 GPIO 口，并串联限流电阻。&lt;/li>
&lt;li>&lt;strong>蜂鸣器&lt;/strong>：蜂鸣器连接到单片机的一个 GPIO 口，并根据需要添加限流电阻或驱动电路。&lt;/li>
&lt;li>&lt;strong>光敏电阻&lt;/strong>：光敏电阻连接到单片机的 ADC 输入端，以便读取光照强度。&lt;/li>
&lt;/ul>
&lt;h3 id="第三步软件编程">第三步：软件编程
&lt;/h3>&lt;h4 id="初始化">初始化
&lt;/h4>&lt;ul>
&lt;li>配置定时器用作延时函数的基础。&lt;/li>
&lt;li>设置 I/O 端口的方向，初始化数码管和 LED 灯的状态。&lt;/li>
&lt;/ul>
&lt;h4 id="主程序逻辑">主程序逻辑
&lt;/h4>&lt;ul>
&lt;li>创建主循环，在其中等待按键事件。&lt;/li>
&lt;li>当检测到启动按键被按下时，进入工作流程。&lt;/li>
&lt;li>按照预设的时间间隔更新数码管上的显示内容。&lt;/li>
&lt;li>根据当前状态控制 LED 灯亮灭。&lt;/li>
&lt;li>控制步进电机按照预定模式旋转（正转、反转、停止）。&lt;/li>
&lt;/ul>
&lt;h4 id="中断服务程序isr">中断服务程序（ISR）
&lt;/h4>&lt;ul>
&lt;li>如果使用定时器中断，则在 ISR 中处理计时任务，例如更新时间、控制电机旋转等。&lt;/li>
&lt;li>如果使用外部中断来捕捉按键事件，可以在 ISR 中设置标志位或者直接响应按键动作。&lt;/li>
&lt;/ul>
&lt;h4 id="键盘扫描">键盘扫描
&lt;/h4>&lt;ul>
&lt;li>编写键盘扫描函数，定期检查按键状态，以触发相应的动作。&lt;/li>
&lt;/ul>
&lt;h4 id="步进电机控制">步进电机控制
&lt;/h4>&lt;ul>
&lt;li>编写函数来控制步进电机的转动方向和速度，可以通过改变脉冲序列实现正转、反转及停止。&lt;/li>
&lt;/ul>
&lt;h4 id="数码管显示">数码管显示
&lt;/h4>&lt;ul>
&lt;li>编写函数负责将数字转换为 7 段数码管所需的段码，并通过适当的接口发送给数码管。&lt;/li>
&lt;li>根据文献，P2.2/3/4 控制译码器，P0 输出&lt;/li>
&lt;/ul>
&lt;h4 id="光线检测如果有光敏电阻">光线检测（如果有光敏电阻）
&lt;/h4>&lt;ul>
&lt;li>编写函数读取光敏电阻的模拟值，并据此判断是否允许洗衣机工作。&lt;/li>
&lt;/ul>
&lt;h4 id="延时函数">延时函数
&lt;/h4>&lt;p>定时器实现：&lt;/p>
&lt;p>双循环实现：&lt;/p>
&lt;h4 id="独立按键">独立按键
&lt;/h4>&lt;ul>
&lt;li>按下按键1后按工作流程开始工作&lt;/li>
&lt;li>在洗衣机工作过程中的任意时间按下按键2，立即结束流程停转&lt;/li>
&lt;li>根据文献，P3.0~3 分别有对应：
1 &amp;ndash;&amp;gt; 3.1
2 &amp;ndash;&amp;gt; 3.0
3 &amp;ndash;&amp;gt; 3.2
4 &amp;ndash;&amp;gt; 3.3&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[!Caution]+ 目前已经使用的口
LSA/B/C &amp;mdash;&amp;gt; P2^2&lt;del>4
SMG_A_DP_PORT &amp;mdash;&amp;gt; P0
KEY 1-4 &amp;mdash;&amp;gt; P3.0&lt;/del>3&lt;/p>
&lt;/blockquote></description></item><item><title>因你而在的故事</title><link>https://mountainatic.github.io/posts/%E5%9B%A0%E4%BD%A0%E8%80%8C%E5%9C%A8%E7%9A%84%E6%95%85%E4%BA%8B/</link><pubDate>Mon, 11 Aug 2025 22:54:29 +0800</pubDate><guid>https://mountainatic.github.io/posts/%E5%9B%A0%E4%BD%A0%E8%80%8C%E5%9C%A8%E7%9A%84%E6%95%85%E4%BA%8B/</guid><description>&lt;p>&lt;figure class="image-container">
&lt;img src="https://mountainatic.github.io/images/real.png"
loading="lazy"
alt="real.png"
class="responsive-image"
>
&lt;figcaption>real.png&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h1 id="看图看图看图理解">&lt;strong>==看图！看图！看图理解！==&lt;/strong>
&lt;/h1>&lt;p>==&lt;strong>不需要深究物理原理，知道每个部分有啥功能就行，原理都是从功能角度设计的！！！&lt;/strong>==&lt;/p>
&lt;h2 id="存储器部分">存储器部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>RAM 地址寄存器&lt;/strong>：存储了 RAM 中数据的地址（包括 RAM 和 AUX-RAM），CPU 在需要读写 RAM 时候告诉 CPU 数据的存取位置&lt;/li>
&lt;li>&lt;strong>RAM&lt;/strong>：更靠近 CPU，存放局部变量、寄存器的值等&lt;/li>
&lt;li>*&lt;em>AUX-RAM&lt;/em>：“物理上片内，逻辑上外部”，扩展内存，是辅助 RAM 存放更多数据的&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol start="4">
&lt;li>&lt;strong>程序存储器（Flash）&lt;/strong>：永久==保存程序、固件等大块数据==，断电不丢失，MCU 启动后从这里运行&lt;/li>
&lt;li>&lt;strong>EEPROM&lt;/strong>：用于保存需要长期存储的值，断电不丢失，主要==储存经常需要修改的少量数据==，如==配置参数、用户设置、校准数据等==&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>[!notes] 区别&lt;/p>
&lt;ul>
&lt;li>Flash 一般成块（Block）或者页（Page）写入，速度快，写入寿命比下面的短，但容量大&lt;/li>
&lt;li>EEPROM 支持按字节写入，适合修改少量数据，速度慢，写入寿命比上面的长，但容量小&lt;/li>
&lt;li>后记：实际上目前国产STC宏晶系列不管是Flash还是EEPROM都全用上Flash芯片了，也不是特别分这个，实际不是MCU仙人，平常做项目根本没有要写进这里面的，相当于是断电还要保存的数据，要断电重启的项目应该也开始用stm32之类的了，51还是太简单了（逃）&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="运算控制部分">运算控制部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>ACC（累加器）&lt;/strong>
&lt;ul>
&lt;li>本质是一个寄存器，用来==存储==运算过程中的数据和最终结果&lt;/li>
&lt;li>叫累加器是==因为经常在累加过程中用到==，当然==加减法逻辑运算都支持==&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**临时寄存器（TMP1 &amp;amp; TMP2）
&lt;ul>
&lt;li>用于保存中间数据&lt;/li>
&lt;li>两个可能是因为方便复杂运算（第一步结果存到 1，第二步存到 2）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ALU（算术逻辑单元）&lt;/strong>
&lt;ul>
&lt;li>==执行==所有算术和逻辑运算&lt;/li>
&lt;li>从累加器和临时寄存器去除操作数，计算，存回累加器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>PSW（程序状态字寄存器）&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：
主要用来==记录计算状态==，记录的是标志位，如：
&lt;ul>
&lt;li>&lt;strong>进位标志（CY）：&lt;/strong> 如果运算结果超过了寄存器的存储能力（比如 8 位运算结果超过 255），就会设置进位标志。&lt;/li>
&lt;li>&lt;strong>零标志（Z）：&lt;/strong> 如果运算结果是 0，这个位会被置位。&lt;/li>
&lt;li>&lt;strong>溢出标志（OV）：&lt;/strong> 如果运算结果超出了允许的范围（比如符号位有问题），会设置这个标志。
&lt;em>&lt;strong>记录的是重要事件，相当于备忘录，“师傅，该进一了”&lt;/strong>&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol start="5">
&lt;li>&lt;strong>双数据指针&lt;/strong>
&lt;ul>
&lt;li>允许MCU同时指向两个不同的内存地址，可以快速切换数据（&lt;del>左脚踩右脚&lt;/del>）&lt;/li>
&lt;li>比如：一个读数据，一个写数据；左右交替处理数组之类的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>堆栈指针&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>就像一个==书签==，标识/记录堆栈的顶部位置&lt;/strong>&lt;/li>
&lt;li>堆栈是一个特殊的内存区域，用来管理程序调用，比如函数之间的跳转和返回&lt;/li>
&lt;li>该指针可以在：
&lt;ul>
&lt;li>调用一个函数时，保存当前的位置，以便函数执行完毕后可以正确返回&lt;/li>
&lt;li>嵌套函数调用中，“找对正确的路”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="定时通信部分">定时通信部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>定时器 0/1 与定时器 2&lt;/strong>
&lt;ul>
&lt;li>精确管理时间/计数，如：时间控制、时间计数&lt;/li>
&lt;li>&lt;strong>大概的模式&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>定时模式&lt;/strong>：根据时钟源计时，达到设定时间后触发一个中断&lt;/li>
&lt;li>&lt;strong>计数模式&lt;/strong>：根据外部输入信号脉冲个数计数，达到几几次后触发中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多个定时器便于同时管理多个任务&lt;/li>
&lt;li>0/1 和 2 分开==可能是==因为 0 与 1 设计差不多，而与 2 不一样&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>串口（UART）&lt;/strong>
&lt;ul>
&lt;li>MCU 与其他设备通信的桥梁，使用&lt;strong>串行通信协议&lt;/strong>，一位一位地发送信息&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>
&lt;ul>
&lt;li>单通道：MCU 一次只能与一个设备通信（用协议可以在外拓展）&lt;/li>
&lt;li>速度调节：支持不同波特率（传输速度）&lt;/li>
&lt;li>双向通信：允许双向发送消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>看门狗定时器（WDT）&lt;/strong>
&lt;ul>
&lt;li>安全机制，程序正常运行时，MCU 会定期重置 WDT；==当程序卡住/死循环==，看门狗没有被重置，WDT 会触发==复位==，重新启动 MCU&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="程序控制--存储器交互部分">程序控制 &amp;amp; 存储器交互部分
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>PC（程序计数器）&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：是一个寄存器，用来储存当前正在执行的指令的地址，引导执行下一条指令&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>：
&lt;ul>
&lt;li>每执行一条指令，PC 的值自动增加，指向下一个指令的地址&lt;/li>
&lt;li>遇到跳转指令时候（&lt;code>JUMP&lt;/code> 或者 &lt;code>CALL&lt;/code> 等），PC 会被修改为跳转目标的地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>地址生成器&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用：&lt;/strong> 地址生成器负责生成 MCU 内部各模块所需的存储器地址。
&lt;ul>
&lt;li>包括程序存储器（Flash）、数据存储器（RAM）和特殊功能寄存器（SFR）的地址。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>用途：&lt;/strong>
&lt;ul>
&lt;li>当处理器需要从存储器读取数据或写入数据时，地址生成器会根据指令提供对应的地址。&lt;/li>
&lt;li>它与程序计数器配合，确保指令和数据在正确的时间被正确访问。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>[!Question] 为什么 PC 和地址生成器都要的是“地址”，而感觉好像这俩地址不一样？
因为==PC==中的地址是&lt;strong>逻辑地址&lt;/strong>，是&lt;strong>抽象地址&lt;/strong>
而真正的&lt;strong>物理地址&lt;/strong>是由&lt;strong>地址生成器&lt;/strong>处理的，它将 PC 的逻辑地址查找/计算出对应物理地址
因此实际的时序是：当处理器准备取下一条指令时候，PC 的值已经更新，递给地址生成器，其根据这个值生成对应 Flash 中地址&lt;/p>
&lt;/blockquote>
&lt;ol start="3">
&lt;li>&lt;strong>Flash（程序存储器）&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：一般用来存储程序，可反复擦写，运行时只读，编程时可以通过 ISP/IAP 擦写&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ISP/IAP（在线编程与应用编程）&lt;/strong>
&lt;ul>
&lt;li>ISP：通过特定接口（USB、串口）修改 Flash 内容&lt;/li>
&lt;li>IAP：程序运行时，更新 Flash 中的部分内容（比如 OTA）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol start="5">
&lt;li>&lt;strong>存储器和控制模块的协作&lt;/strong>
&lt;ul>
&lt;li>PC 指向当前指令的地址&lt;/li>
&lt;li>地址生成器根据 PC 提供的地址，从程序存储器中读取指令（实际上是 Flash 读取指令，生成器只是生成了地址）&lt;/li>
&lt;li>指令被送到控制单元，控制单元解析指令并产生对应的操作&lt;/li>
&lt;li>如果需要访问数据存储器（RAM）或特殊寄存器，地址生成器会生成相应的地址&lt;/li>
&lt;li>执行完成后，PC 自动指向下一条指令，进入下一个循环&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="io-接口">I/O 接口
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>锁存器(Port 0,1,2,3,4 锁存器)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>保存和稳定数据&lt;/strong>。用于保存 I/O 口的数据状态，比如，当 CPU 将一个数据写入到某个 I/O 端口时，锁存器负责将数据固定，直到被下一个数据覆盖&lt;/li>
&lt;li>&lt;strong>双向的&lt;/strong>。可以把==输出==的信号稳定，也可以把==输入==的信号去抖/同步/&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>工作方式&lt;/strong>：
&lt;ul>
&lt;li>CPU 输出数据时，数据会经过总线，先进入锁存器，锁存器会将其稳定后再传递给 I/O 驱动器&lt;/li>
&lt;li>锁存器会&lt;strong>暂时存储&lt;/strong>从总线上传输的数据，并将其锁定（Latch）。直到信号完全稳定后，才会将数据传递给后续模块（如 I/O 驱动器）。&lt;/li>
&lt;li>锁存器通过时钟信号或者控制信号同步数据切换，确保输出的信号是一个完整、确定的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>&lt;strong>提供了 MCU 内部与外部的缓冲区和隔离层&lt;/strong>&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>驱动器&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>
&lt;ul>
&lt;li>负责将锁存器输出的数据==传出==物理引脚&lt;/li>
&lt;li>==接收==外部信号，通过驱动器传递到 CPU
&lt;em>通常有电平转换电路，用于适应不同的外部设备电压要求&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>I/O 引脚（P0, P1, P2, P3, P4）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>
&lt;ul>
&lt;li>不同的端口支持不同的功能，例如某些引脚可以配置为 UART、SPI、I2C 或 ADC 通道。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>数据流&lt;/strong>
&lt;ul>
&lt;li>当 CPU 要输出数据时：数据 → 锁存器 → 驱动器 → I/O 引脚。&lt;/li>
&lt;li>当 CPU 要读取数据时：外部信号 → I/O 引脚 → 驱动器 → CPU。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="控制单元">控制单元
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：协调模块运作，解析指令，产生控制信号&lt;/li>
&lt;li>&lt;strong>组成&lt;/strong>：
&lt;ol>
&lt;li>&lt;strong>时钟电路&lt;/strong>：XTAL1 与 XTAL2 是外部晶振接口，提供一个固定频率的时钟信号&lt;/li>
&lt;li>&lt;strong>复位引脚&lt;/strong>：重新加载程序计数器、清空寄存器，确保系统从头开始运行&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>作用&lt;/strong>：
&lt;ol>
&lt;li>从存储器中取出指令&lt;/li>
&lt;li>解析指令内容&lt;/li>
&lt;li>生成操作信号&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="总线">总线
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>传递数据、地址和控制信号的通道&lt;/strong>&lt;/li>
&lt;li>&lt;strong>分类：&lt;/strong>
&lt;ol>
&lt;li>数据总线&lt;/li>
&lt;li>地址总线&lt;/li>
&lt;li>控制总线&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>总线是一种共享资源。为了避免多个模块同时使用总线导致冲突，MCU 内部会有一个&lt;strong>总线仲裁器&lt;/strong>（Bus Arbiter）来管理总线的访问权。&lt;/li>
&lt;/ul></description></item></channel></rss>